// Generated by CoffeeScript 1.4.0
(function() {
  'use strict';

  /*
  ===============================================================================
  The function deletes the elements of an array which have values ixDelete
  and change elements with values ixUpdate to ixDelete.
  */

  /*
  ===============================================================================
  Returns the position in the array nodes which the node has been put to.
  */

  var add_edge, add_node, del_edge, del_node, has_edge, ins_edge, ins_node, move_graph, upd_edge;

  add_node = function(x, y) {
    graph.nodes.x.push(x);
    return graph.nodes.y.push(y) - 1;
  };

  ins_node = function(x, y, ix) {
    if (ix < graph.nodes.x.length) {
      graph.nodes.x.push(graph.nodes.x[ix]);
      graph.nodes.y.push(graph.nodes.y[ix]);
    }
    graph.nodes.x[ix] = x;
    graph.nodes.y[ix] = y;
    return ix;
  };

  /*
  We delete an element [ix] of an array as follows:
  1. Copy the last element to the position ix.
  2. Remove the last element.
  Returns the value at deleted position
  */


  del_node = function(ix) {
    var len, ret;
    ret = null;
    if ((ix < (len = graph.nodes.x.length)) && (ix > -1)) {
      if (ix === len - 1) {
        ret = [graph.nodes.x.pop(), graph.nodes.y.pop()];
      } else {
        ret = [graph.nodes.x[ix], graph.nodes.y[ix]];
        graph.nodes.x[ix] = graph.nodes.x.pop();
        graph.nodes.y[ix] = graph.nodes.y.pop();
      }
    }
    return ret;
  };

  this.move_node = function(ix, x, y) {
    graph.nodes.x[ix] = x;
    graph.nodes.y[ix] = y;
    return null;
  };

  /*
  ===============================================================================
  */


  add_edge = function(node_ix1, node_ix2) {
    var eix, ret;
    eix = has_edge(node_ix2, node_ix1);
    ret = graph.edges.push(pack(node_ix1, node_ix2)) - 1;
    if ((graph.curved[ret] = eix >= 0)) {
      graph.curved[eix] = true;
    }
    return ret;
  };

  /*
  ===============================================================================
  */


  ins_edge = function(node_ix1, node_ix2, ix) {
    var eix;
    eix = has_edge(node_ix2, node_ix1);
    if (ix < graph.edges.length) {
      graph.edges.push(graph.edges[ix]);
      graph.curved.push(graph.curved[ix]);
    }
    graph.edges[ix] = pack(node_ix1, node_ix2);
    if (eix < 0) {
      graph.curved[ix] = false;
    } else {
      if (eix === ix) {
        eix = graph.edges.length - 1;
      }
      graph.curved[ix] = graph.curved[eix] = true;
    }
    return ix;
  };

  /*
  ===============================================================================
  */


  del_edge = function(ix) {
    var a, b, eix, len, ret, _ref;
    ret = null;
    if ((ix < (len = graph.edges.length)) && (ix > -1)) {
      _ref = unpack(graph.edges[ix]), a = _ref[0], b = _ref[1];
      if (ix === len - 1) {
        ret = graph.edges.pop();
        graph.curved.pop();
      } else {
        ret = graph.edges[ix];
        graph.edges[ix] = graph.edges.pop();
        graph.curved[ix] = graph.curved.pop();
      }
      if ((eix = has_edge(b, a)) >= 0) {
        graph.curved[eix] = false;
      }
    }
    return ret;
  };

  /*
  ===============================================================================
  */


  has_edge = function(from_node, to_node) {
    var edge, index, packed, _i, _len, _ref;
    packed = pack(from_node, to_node);
    _ref = graph.edges;
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      edge = _ref[index];
      if (edge === packed) {
        return index;
      }
    }
    return -1;
  };

  upd_edge = function(ix, val) {
    graph.edges[ix] = val;
    return null;
  };

  /*
  ===============================================================================
  */


  move_graph = function(dx, dy) {
    var index, x, _i, _len, _ref;
    _ref = graph.nodes.x;
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      x = _ref[index];
      graph.nodes.x[index] += dx;
      graph.nodes.y[index] += dy;
    }
    return null;
  };

  /*
  ===============================================================================
  */


  this.editor = {
    stack: [],
    ix: 0,
    transaction: false,
    execute: function() {
      var args, name;
      name = arguments[0];
      args = Array.prototype.slice.call(arguments).splice(1);
      if (!!this[name]) {
        return this[name].apply(this, args);
      }
      console.log("Command not found: " + name + " (" + args + ")");
      return null;
    },
    undo: function() {
      var cmd, ret;
      ret = false;
      if (this.ix > 0) {
        while (this.ix > 0) {
          cmd = this.stack[--this.ix];
          cmd.undo_func.apply(this, cmd.undo_vals);
          if (!this.transaction) {
            break;
          }
        }
        ret = true;
      }
      return ret;
    },
    redo: function() {
      var cmd, ret;
      ret = false;
      if (this.ix < this.stack.length) {
        while (this.ix < this.stack.length) {
          cmd = this.stack[this.ix++];
          cmd.redo_func.apply(this, cmd.redo_vals);
          if (!this.transaction) {
            break;
          }
        }
        ret = true;
      }
      return ret;
    },
    to_stack: function(redo_func, redo_vals, undo_func, undo_vals) {
      if (this.ix < this.stack.length) {
        this.stack.length = this.ix;
      }
      this.stack.push({
        redo_func: redo_func,
        redo_vals: redo_vals,
        undo_func: undo_func,
        undo_vals: undo_vals
      });
      this.ix = this.stack.length;
      return null;
    },
    set_transaction: function(state) {
      return this.transaction = state;
    },
    start_transaction: function() {
      return this.to_stack(this.set_transaction, [true], this.set_transaction, [false]);
    },
    stop_transaction: function() {
      return this.to_stack(this.set_transaction, [false], this.set_transaction, [true]);
    },
    add_node: function(x, y) {
      var ix;
      ix = add_node(x, y);
      this.to_stack(add_node, arguments, del_node, [ix]);
      return ix;
    },
    del_node: function(ix) {
      var i, last, v1, v2, v_old, x, y, _ref;
      x = graph.nodes.x[ix];
      y = graph.nodes.y[ix];
      last = graph.nodes.length - 1;
      del_node(ix);
      this.start_transaction();
      this.to_stack(del_node, [ix], ins_node, [x, y, ix]);
      i = graph.edges.length;
      while (i-- > 0) {
        _ref = unpack(graph.edges[i]), v1 = _ref[0], v2 = _ref[1];
        if ((v1 === ix) || (v2 === ix)) {
          this.del_edge(i);
        } else if (ix < last) {
          v_old = graph.edges[i];
          if (v1 === last) {
            v1 = ix;
          }
          if (v2 === last) {
            v2 = ix;
          }
          if ((v1 === ix) || (v2 === ix)) {
            upd_edge(i, pack(v1, v2));
            this.to_stack(upd_edge, [i, graph.edges[i]], upd_edge, [i, v_old]);
          }
        }
      }
      this.stop_transaction();
      return null;
    },
    move_node: function(ix, x1, y1, x2, y2) {
      this.to_stack(move_node, [ix, x2, y2], move_node, [ix, x1, y1]);
      return null;
    },
    add_edge: function(node_ix1, node_ix2) {
      var ix;
      ix = add_edge(node_ix1, node_ix2);
      this.to_stack(add_edge, [node_ix1, node_ix2], del_edge, [ix]);
      return ix;
    },
    del_edge: function(ix) {
      var nodes, v1, v2, _ref;
      nodes = del_edge(ix);
      _ref = unpack(nodes), v1 = _ref[0], v2 = _ref[1];
      this.to_stack(del_edge, [ix], ins_edge, [v1, v2, ix]);
      return null;
    },
    move_graph: function(x1, y1, x2, y2) {
      var dx, dy;
      dx = x2 - x1;
      dy = y2 - y1;
      if (dx || dy) {
        move_graph(dx, dy);
        this.to_stack(move_graph, [dx, dy], move_graph, [-dx, -dy]);
      }
      return null;
    }
  };

}).call(this);
