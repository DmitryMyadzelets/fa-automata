// Generated by CoffeeScript 1.6.2
(function() {
  'use strict';
  var a, b,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  this.digraph = {
    create: function() {
      return {
        nodes: {
          v: []
        },
        edges: {
          a: [],
          b: [],
          v: []
        }
      };
    },
    edges: {
      add: function(G, a, b, i) {
        if (i == null) {
          i = digraph.for_arrays_of(G.edges, (function(arr) {
            return arr.push(null);
          })) - 1;
        } else {
          digraph.for_arrays_of(G.edges, (function(arr) {
            return digraph.ins(arr, i);
          }));
        }
        G.edges.a[i] = a;
        G.edges.b[i] = b;
        return i;
      },
      del: function(G, i) {
        return digraph.for_arrays_of(G.edges, digraph.del, i);
      },
      get: function(G, i) {
        return G.edges.v[i];
      },
      set: function(G, i, v) {
        return G.edges.v[i] = v;
      },
      out: function(G, from_node) {
        var b, i, _i, _len, _ref, _results;

        _ref = G.edges.b;
        _results = [];
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          b = _ref[i];
          if (G.edges.a[i] === from_node) {
            _results.push(i);
          }
        }
        return _results;
      },
      has: function(G, a, b) {
        var i, ix, _i, _len, _ref;

        _ref = G.edges.b;
        for (ix = _i = 0, _len = _ref.length; _i < _len; ix = ++_i) {
          i = _ref[ix];
          if (G.edges.a[ix] === a && i === b) {
            return true;
          }
        }
        return false;
      }
    },
    nodes: {
      add: function(G, i) {
        if (i == null) {
          i = digraph.for_arrays_of(G.nodes, (function(arr) {
            return arr.push(null);
          })) - 1;
        } else {
          digraph.for_arrays_of(G.nodes, (function(arr) {
            return digraph.ins(arr, i);
          }));
        }
        return i;
      },
      del: function(G, i) {
        return digraph.for_arrays_of(G.nodes, digraph.del, i);
      },
      get: function(G, i) {
        return G.nodes.v[i];
      },
      set: function(G, i, v) {
        return G.nodes.v[i] = v;
      },
      out: function(G, from_node) {
        var b, i, _i, _len, _ref, _results;

        _ref = G.edges.b;
        _results = [];
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          b = _ref[i];
          if (G.edges.a[i] === from_node) {
            _results.push(b);
          }
        }
        return _results;
      },
      "in": function(G, to_node) {
        var a, i, _i, _len, _ref, _results;

        _ref = G.edges.a;
        _results = [];
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          a = _ref[i];
          if (G.edges.b[i] === to_node) {
            _results.push(a);
          }
        }
        return _results;
      }
    },
    /* 
    	# Helper methods
    	# =======================================================================
    */

    ins: function(arr, i, val) {
      if (i < arr.length) {
        arr.push(arr[i]);
        arr[i] = val;
      } else {
        arr.push(val);
      }
      return i;
    },
    del: function(arr, i) {
      var last, ret;

      ret = -1;
      if (i >= 0) {
        last = arr.length - 1;
        if (i < last) {
          arr[i] = arr.pop();
          ret = i;
        } else if (i === last) {
          arr.pop();
          ret = i;
        }
      }
      return ret;
    },
    get_arrays: function(obj) {
      var key, keys;

      keys = [];
      for (key in obj) {
        if (obj[key] instanceof Array) {
          keys.push(key);
        }
      }
      return keys;
    },
    for_arrays_of: function(obj, fnc, args) {
      var key, keys, ret, _i, _len;

      keys = this.get_arrays(obj);
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        key = keys[_i];
        ret = fnc(obj[key], args);
      }
      return ret;
    }
  };

  this.fa = Object.create(digraph);

  fa.extend = function(G) {
    G.start = 0;
    G.events = {
      v: []
    };
    return G;
  };

  fa.create = function() {
    var G;

    G = digraph.create();
    return fa.extend(G);
  };

  fa.events = {
    add: function(G, v, i) {
      var ix;

      if (v == null) {
        return -1;
      }
      if ((ix = G.events.v.indexOf(v)) >= 0) {
        return ix;
      }
      if (i == null) {
        i = fa.for_arrays_of(G.events, (function(arr) {
          return arr.push(null);
        })) - 1;
      } else {
        fa.for_arrays_of(G.events, (function(arr) {
          return fa.ins(arr, i);
        }));
      }
      G.events.v[i] = v;
      return i;
    },
    del: function(G, i) {
      return fa.for_arrays_of(G.events, fa.del, i);
    }
  };

  fa.BFS = function(G) {
    var E, a, b, e, stack, visited, _i, _len;

    stack = [G.start];
    visited = [G.start];
    while (stack.length) {
      a = stack.pop();
      E = this.edges.out(G, a);
      for (_i = 0, _len = E.length; _i < _len; _i++) {
        e = E[_i];
        b = G.edges.b[e];
        if (__indexOf.call(visited, b) < 0) {
          visited.push(b);
          stack.push(b);
        }
        console.log(a, "->", b);
      }
    }
    return null;
  };

  this.faxy = Object.create(fa);

  faxy.extend = function(G) {
    G.nodes.x = [];
    G.nodes.y = [];
    return G;
  };

  faxy.create = function() {
    var G;

    G = fa.create();
    return faxy.extend(G);
  };

  this.g = faxy.create();

  console.log(a = faxy.nodes.add(g));

  console.log(b = faxy.nodes.add(g));

  console.log(faxy.edges.add(g, a, b));

  console.log(faxy.edges.add(g, a, a));

  console.log(faxy.edges.add(g, b, b));

  console.log("Nodes: ", g.nodes);

  console.log("Edges: ", g.edges);

  /* TODO:
  - Make dependence consistency (nodes <- edges) for deletion 
    and (events to edges) update.
  */


}).call(this);
