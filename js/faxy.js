// Generated by CoffeeScript 1.6.2
(function() {
  'use strict';
  var vector;

  vector = {
    create: function() {
      return new Float32Array([0, 0]);
    },
    length: function(v) {
      return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
    },
    normalize: function(v, out) {
      var len;

      len = length(v);
      len = 1 / len;
      out[0] = v[0] * len;
      out[1] = v[1] * len;
      return out;
    },
    orthogonal: function(v, out) {
      out[0] = v[1];
      out[1] = -v[0];
      return out;
    },
    subtract: function(a, b, out) {
      out[0] = a[0] - b[0];
      out[1] = a[1] - b[1];
      return out;
    }
  };

  this.faxyz = (function($) {
    var arrow, curved, update_node, _this;

    arrow = function(to, a, n) {
      a[0] = to[0];
      a[1] = to[1];
      a[2] = a[0] - (10 * n[0]) + (4 * n[1]);
      a[3] = a[1] - (10 * n[1]) - (4 * n[0]);
      a[4] = a[2] - (8 * n[1]);
      a[5] = a[3] + (8 * n[0]);
      return a;
    };
    curved = function(v1, v2, norm, orth, cv, arrow) {
      var n, o, v;

      v = vector.create();
      vector.subtract(v2, v1, v);
      vector.normalize(v, norm);
      cv[0] = (v1[0] + v2[0]) / 2 + norm[1] * 40;
      cv[1] = (v1[1] + v2[1]) / 2 - norm[0] * 40;
      n = vector();
      o = vector();
      calc_norm_ort(v1, cv, n, o);
      normal(v1, n);
      calc_edge(v1, [], n);
      calc_norm_ort(cv, v2, n, o);
      calc_edge([], v2, n);
      calc_arrow(v2, n, o, arrow);
      return null;
    };
    update_node = function(G, a) {
      var e, i, inout, ix, v1, v2, x1, x2, y1, y2;

      inout = $.edges.out(G, a).concat($.edges["in"](G, a));
      i = inout.length;
      while (i-- > 0) {
        ix = inout[i];
        v1 = G.edges.a[ix];
        v2 = G.edges.b[ix];
        x1 = G.nodes.x[v1];
        y1 = G.nodes.y[v1];
        x2 = G.nodes.x[v2];
        y2 = G.nodes.y[v2];
        e = G.edges;
        if (v1 !== v2) {
          e.v1[ix][0] = x1;
          e.v1[ix][1] = y1;
          e.v2[ix][0] = x2;
          e.v2[ix][1] = y2;
          if (e.curved[ix]) {
            window.calc_curved(e.v1[ix], e.v2[ix], e.norm[ix], e.orth[ix], e.cv[ix], e.arrow[ix]);
          } else {
            window.calc_norm_ort(e.v1[ix], e.v2[ix], e.norm[ix], e.orth[ix]);
            window.calc_edge(e.v1[ix], e.v2[ix], e.norm[ix]);
            window.calc_arrow(e.v2[ix], e.norm[ix], e.orth[ix], e.arrow[ix]);
          }
        } else {
          null;
        }
      }
      return null;
    };
    _this = {
      create: function() {
        var G;

        G = $.create();
        _this.extend(G);
        return G;
      },
      extend: function(G) {
        G.nodes.x = [];
        G.nodes.y = [];
        G.edges._ = [];
        return G;
      },
      nodes: Object.create($.nodes),
      edges: Object.create($.edges)
    };
    _this.nodes.add = function(G, x, y) {
      var ix;

      ix = $.nodes.add(G);
      G.nodes.x[ix] = x;
      G.nodes.y[ix] = y;
      return ix;
    };
    _this.nodes.move = function(G, i, x, y) {
      if (i < G.nodes.length && i > -1) {
        G.nodes.x[i] = x;
        G.nodes.y[i] = y;
      }
      return i;
    };
    _this.edges.add = function(G, a, b, args) {
      var eix, ix;

      if ($.edges.has(G, a, b) > -1) {
        return -1;
      }
      eix = $.edges.has(G, b, a);
      ix = $.edges.add(G, a, b, args);
      if (ix >= 0) {
        G.edges._[ix] = function() {
          return {
            curved: false,
            v1: vector(),
            v2: vector(),
            cv: vector(),
            norm: vector(),
            orth: vector(),
            arrow: [vector(), vector(), vector()]
          };
        };
        if (eix >= 0) {
          G.edges._[eix].curved = true;
          G.edges._[ix].curved = true;
        }
      }
      return ix;
    };
    _this.edges.del = function(G, i) {
      var a, b, eix, ix;

      a = G.edges.a[i];
      b = G.edges.b[i];
      if ((ix = fa.edges.del(G, i)) >= 0) {
        if ((eix = fa.edges.has(G, b, a)) >= 0) {
          G.edges._[eix].curved = false;
        }
      }
      return ix;
    };
    return _this;
  })(fa);

  this.faxy = Object.create(fa);

  faxy.create = function() {
    var G;

    G = fa.create();
    faxy.extend(G);
    faxyz.extend(G);
    return G;
  };

  faxy.extend = function(G) {
    G.nodes.x = [];
    G.nodes.y = [];
    vector = function() {
      return new Float32Array([0, 0]);
    };
    G.edges.curved = [];
    G.edges.v1 = [];
    G.edges.v2 = [];
    G.edges.cv = [];
    G.edges.norm = [];
    G.edges.orth = [];
    G.edges.arrow = [];
    return G;
  };

  faxy.nodes = Object.create(fa.nodes);

  faxy.edges = Object.create(fa.edges);

  faxy.nodes.add = function(G, x, y) {
    var ix;

    ix = fa.nodes.add(G);
    G.nodes.x[ix] = x;
    G.nodes.y[ix] = y;
    return ix;
  };

  faxy.nodes.move = function(G, i, x, y) {
    if (i < G.nodes.length && i > -1) {
      G.nodes.x[i] = x;
      G.nodes.y[i] = y;
      faxy.edges.update_xy(G, i);
    }
    return i;
  };

  faxy.edges.add = function(G, a, b, args) {
    var eix, ix;

    if (fa.edges.has(G, a, b) > -1) {
      return -1;
    }
    eix = fa.edges.has(G, b, a);
    ix = fa.edges.add(G, a, b, args);
    if (ix >= 0) {
      G.edges.v1[ix] = [];
      G.edges.v2[ix] = [];
      G.edges.cv[ix] = [];
      G.edges.norm[ix] = [];
      G.edges.orth[ix] = [];
      G.edges.arrow[ix] = [];
      if (eix >= 0) {
        G.edges.curved[eix] = true;
        G.edges.curved[ix] = true;
      }
    }
    faxy.edges.update_xy(G, a, b);
    return ix;
  };

  faxy.edges.del = function(G, i) {
    var a, b, eix, ix;

    a = G.edges.a[i];
    b = G.edges.b[i];
    if ((ix = fa.edges.del(G, i)) >= 0) {
      if ((eix = fa.edges.has(G, b, a)) >= 0) {
        G.edges.curved[eix] = false;
      }
    }
    return ix;
  };

  faxy.edges.update_xy = function(G, a, b) {
    var e, i, inout, ix, v1, v2, x1, x2, y1, y2;

    inout = faxy.edges.out(G, a).concat(faxy.edges["in"](G, a));
    i = inout.length;
    while (i-- > 0) {
      ix = inout[i];
      v1 = G.edges.a[ix];
      v2 = G.edges.b[ix];
      x1 = G.nodes.x[v1];
      y1 = G.nodes.y[v1];
      x2 = G.nodes.x[v2];
      y2 = G.nodes.y[v2];
      e = G.edges;
      if (v1 !== v2) {
        e.v1[ix][0] = x1;
        e.v1[ix][1] = y1;
        e.v2[ix][0] = x2;
        e.v2[ix][1] = y2;
        if (e.curved[ix]) {
          window.calc_curved(e.v1[ix], e.v2[ix], e.norm[ix], e.orth[ix], e.cv[ix], e.arrow[ix]);
        } else {
          window.calc_norm_ort(e.v1[ix], e.v2[ix], e.norm[ix], e.orth[ix]);
          window.calc_edge(e.v1[ix], e.v2[ix], e.norm[ix]);
          window.calc_arrow(e.v2[ix], e.norm[ix], e.orth[ix], e.arrow[ix]);
        }
      } else {
        null;
      }
    }
    return null;
  };

}).call(this);
