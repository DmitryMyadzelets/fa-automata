// Generated by CoffeeScript 1.6.2
(function() {
  'use strict';
  var vec;

  vec = {
    create: function() {
      return new Float32Array([0, 0]);
    },
    length: function(v) {
      return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
    },
    normalize: function(v, out) {
      var len;

      len = vec.length(v);
      len = 1 / len;
      out[0] = v[0] * len;
      out[1] = v[1] * len;
      return out;
    },
    orthogonal: function(v, out) {
      out[0] = v[1];
      out[1] = -v[0];
      return out;
    },
    scale: function(a, rate, out) {
      out[0] = a[0] * rate;
      out[1] = a[1] * rate;
      return out;
    },
    add: function(a, b, out) {
      out[0] = a[0] + b[0];
      out[1] = a[1] + b[1];
      return out;
    },
    subtract: function(a, b, out) {
      out[0] = a[0] - b[0];
      out[1] = a[1] - b[1];
      return out;
    },
    copy: function(a, out) {
      out[0] = a[0];
      out[1] = a[1];
      return out;
    }
  };

  this.faxy = (function($) {
    var arrow, create_edge_data, curved, fake, fake_edge, start, stright, update_node, _this;

    arrow = function(to, a, n) {
      a[0] = to[0];
      a[1] = to[1];
      a[2] = a[0] - (10 * n[0]) + (4 * n[1]);
      a[3] = a[1] - (10 * n[1]) - (4 * n[0]);
      a[4] = a[2] - (8 * n[1]);
      a[5] = a[3] + (8 * n[0]);
      return a;
    };
    stright = function(v1, v2, norm) {
      var v;

      v = vec.create();
      vec.subtract(v2, v1, v);
      vec.normalize(v, norm);
      vec.scale(norm, r, v);
      vec.add(v1, v, v1);
      vec.subtract(v2, v, v2);
      return null;
    };
    curved = function(v1, v2, norm, cv, _arrow) {
      var v;

      v = vec.create();
      vec.subtract(v2, v1, v);
      vec.normalize(v, norm);
      cv[0] = (v1[0] + v2[0]) / 2 + norm[1] * 40;
      cv[1] = (v1[1] + v2[1]) / 2 - norm[0] * 40;
      vec.subtract(cv, v1, v);
      vec.normalize(v, v);
      vec.scale(v, r, v);
      vec.add(v1, v, v1);
      vec.subtract(v2, cv, v);
      vec.normalize(v, v);
      vec.scale(v, r, v);
      vec.subtract(v2, v, v2);
      vec.normalize(v, v);
      arrow(v2, _arrow, v);
      return null;
    };
    fake = function(v1, v2, norm, is_new) {
      var v;

      v = vec.create();
      vec.subtract(v2, v1, v);
      vec.normalize(v, norm);
      vec.scale(norm, r, v);
      vec.add(v1, v, v1);
      if (!is_new) {
        vec.subtract(v2, v, v2);
      }
      return null;
    };
    start = function(v2, $) {
      vec.copy(v2, $.v2);
      vec.subtract(v2, [4 * r, 0], $.v1);
      stright($.v1, $.v2, $.norm);
      arrow($.v2, $.arrow, $.norm);
      return null;
    };
    update_node = function(G, a) {
      var e, i, inout, ix, v1, v2;

      inout = $.edges.out(G, a).concat($.edges["in"](G, a));
      i = inout.length;
      while (i-- > 0) {
        ix = inout[i];
        v1 = G.edges.a[ix];
        v2 = G.edges.b[ix];
        e = G.edges.$[ix];
        if (v1 !== v2) {
          vec.copy([G.nodes.x[v1], G.nodes.y[v1]], e.v1);
          vec.copy([G.nodes.x[v2], G.nodes.y[v2]], e.v2);
          if (e.curved) {
            curved(e.v1, e.v2, e.norm, e.cv, e.arrow);
          } else {
            stright(e.v1, e.v2, e.norm);
            arrow(e.v2, e.arrow, e.norm);
          }
        } else {
          null;
        }
      }
      if (a === G.start) {
        start([G.nodes.x[a], G.nodes.y[a]], G.edges.start);
      }
      return null;
    };
    create_edge_data = function() {
      return {
        curved: false,
        v1: vec.create(),
        v2: vec.create(),
        cv: vec.create(),
        norm: vec.create(),
        orth: vec.create(),
        arrow: [vec.create(), vec.create(), vec.create()]
      };
    };
    fake_edge = create_edge_data();
    _this = {
      create: function() {
        var G;

        G = $.create();
        _this.extend(G);
        return G;
      },
      extend: function(G) {
        G.nodes.x = [];
        G.nodes.y = [];
        G.edges.$ = [];
        return G.edges.start = create_edge_data();
      },
      nodes: Object.create($.nodes),
      edges: Object.create($.edges),
      get_fake_edge: function(x1, y1, x2, y2, is_new) {
        vec.copy([x1, y1], fake_edge.v1);
        vec.copy([x2, y2], fake_edge.v2);
        fake(fake_edge.v1, fake_edge.v2, fake_edge.norm, is_new);
        arrow(fake_edge.v2, fake_edge.arrow, fake_edge.norm);
        return fake_edge;
      }
    };
    _this.nodes.add = function(G, x, y) {
      var i;

      i = $.nodes.add(G);
      G.nodes.x[i] = x;
      G.nodes.y[i] = y;
      return i;
    };
    _this.nodes.move = function(G, i, x, y) {
      if (i < G.nodes.length && i > -1) {
        G.nodes.x[i] = x;
        G.nodes.y[i] = y;
        update_node(G, i);
      }
      return i;
    };
    _this.edges.add = function(G, a, b, args) {
      var i, j;

      if ($.edges.has(G, a, b) > -1) {
        return -1;
      }
      j = $.edges.has(G, b, a);
      i = $.edges.add(G, a, b, args);
      if (i >= 0) {
        G.edges.$[i] = create_edge_data();
        if (j >= 0) {
          G.edges.$[j].curved = true;
          G.edges.$[i].curved = true;
        }
      }
      update_node(G, a);
      return i;
    };
    _this.edges.del = function(G, i) {
      var a, b, eix, ix;

      a = G.edges.a[i];
      b = G.edges.b[i];
      if ((ix = fa.edges.del(G, i)) >= 0) {
        if ((eix = fa.edges.has(G, b, a)) >= 0) {
          G.edges.$[eix].curved = false;
          update_node(G, a);
        }
      }
      return ix;
    };
    return _this;
  })(fa);

}).call(this);
