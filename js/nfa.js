// Generated by CoffeeScript 1.6.2
(function() {
  'use strict';
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (typeof Object.create !== 'function') {
    Object.create = function(o) {
      var F;

      F = function() {
        return {};
      };
      F.prototype = o;
      return new F();
    };
  }

  this.fa = Object.create(digraph);

  fa.extend = function(G) {
    G.start = 0;
    G.events = {
      v: []
    };
    G.edges.event = [];
    return G;
  };

  fa.create = function() {
    var G;

    G = digraph.create();
    return fa.extend(G);
  };

  fa.events = {
    add: function(G, v, i) {
      var ix;

      if (v == null) {
        return -1;
      }
      if ((ix = G.events.v.indexOf(v)) >= 0) {
        return ix;
      }
      if (i == null) {
        i = fa.for_arrays_of(G.events, (function(arr) {
          return arr.push(null);
        })) - 1;
      } else {
        fa.for_arrays_of(G.events, (function(arr) {
          return fa.ins(arr, i);
        }));
      }
      G.events.v[i] = v;
      return i;
    },
    del: function(G, i) {
      return fa.for_arrays_of(G.events, fa.del, i);
    }
  };

  fa.BFS = function(G) {
    var E, a, b, e, stack, visited, _i, _len;

    stack = [G.start];
    visited = [G.start];
    while (stack.length) {
      a = stack.pop();
      E = this.edges.out(G, a);
      for (_i = 0, _len = E.length; _i < _len; _i++) {
        e = E[_i];
        b = G.edges.b[e];
        if (__indexOf.call(visited, b) < 0) {
          visited.push(b);
          stack.push(b);
        }
        console.log(a, "->", b);
      }
    }
    return null;
  };

  this.faxy = Object.create(fa);

  faxy.create = function() {
    var G;

    G = fa.create();
    faxy.extend(G);
    return G;
  };

  faxy.extend = function(G) {
    G.nodes.x = [];
    G.nodes.y = [];
    G.edges.curved = [];
    return G;
  };

  faxy.nodes = Object.create(fa.nodes);

  faxy.edges = Object.create(fa.edges);

  faxy.nodes.add = function(G, x, y) {
    var ix;

    ix = fa.nodes.add(G);
    G.nodes.x[ix] = x;
    G.nodes.y[ix] = y;
    return ix;
  };

  faxy.nodes.move = function(G, i, x, y) {
    if (i < G.nodes.length && i > -1) {
      G.nodes.x[i] = x;
      G.nodes.y[i] = y;
    }
    return i;
  };

  faxy.edges.add = function(G, a, b, args) {
    var eix, ix;

    if (fa.edges.has(G, a, b) > -1) {
      return -1;
    }
    eix = fa.edges.has(G, b, a);
    ix = fa.edges.add(G, a, b, args);
    if (ix >= 0 && eix >= 0) {
      G.edges.curved[eix] = true;
      G.edges.curved[ix] = true;
    }
    return ix;
  };

  faxy.edges.del = function(G, i) {
    var a, b, eix, ix;

    a = G.edges.a[i];
    b = G.edges.b[i];
    if ((ix = fa.edges.del(G, i)) >= 0) {
      if ((eix = fa.edges.has(G, b, a)) >= 0) {
        G.edges.curved[eix] = false;
      }
    }
    return ix;
  };

  /* TODO:
  - Would be better if each module knows how to Undo/Redo its actions?
    Then we can have one Undo/Redo stack (or a few context-related), 
    and keep (Module, Undo-Redo couple). An Editor recieves all the 
    user's commands, and sends them to a module. The editor knows if it 
    wants to undo module's actions or not. Then the editor askes the module
    to provide Undo-Redo action for a given command. The editor can:
    1. Tell to the module in advance what place (stack pointer) 
    to put Undo-Redo actions.
    2. Recieve Undo-Redo actions from the module as callbacks.
    The second option seems more relevant, since the editor knows 
    the context (an object) the actions are taken in. Then the editor can
    create an object along with the the stack of actions. Otherwise, 
    (the first option) the editor has to change the module's stack pointer.
  
    In the end it looks like:
    	A)
  	From Editor side:
  		Action with no recording: module[i].action(args)
  		Action with recording: module[i].record(callback[i]).action(args)
  	From Module side:
  		Action with no recording: module.action(args) { do...; ret }
  		Action with recording:
  		module.record(callback) ->
  			fnc = callback
  			return module
  		module.action(args) ->
  			do...
  			call fnc if fnc #if matters
  			fnc = null
  
  	B)
  	From Editor side:
  		Editor knows the module and it knows how to Undo-Redo couples.
  	From Module side:
  		Module has no clue about Undo/Redo.
  
  	But in case if the module has transactions, it has to inform the editor
  	about changes.
  
  	So, either in (A) and (B) Editor and Modules are linked somehow.
  	Those are kinde of Command pattern. 
  	But there exists a Memento pattern also.
  
  	Memento pattern!? 
  	Props:
  		It stores the entire state of the object.
  		Modules have no idea about Undo/Redo
  		Editor has only 2 commands, Undo and Redo and should know the context.
  	Cons:
  		Memory consuming. But this can be solveed storing only difference
  		of module's states.
  
  	Read there:
  		http://stackoverflow.com/questions/10552360/emberjs-history-undo
  		http://stackoverflow.com/questions/1200562/difference-in-json-objects-using-javascript-jquery
  		http://stackoverflow.com/questions/1029241/javascript-object-watch-for-all-browsers/1270182#1270182
  		https://github.com/ArthurClemens/Javascript-Undo-Manager
  
  	Also interesting:
  		Saving files on client side
  		http://eligrey.com/blog/post/saving-generated-files-on-the-client-side
  */


}).call(this);
