// Generated by CoffeeScript 1.6.2
(function() {
  'use strict';
  var Edges, Events, Nodes, extArray;

  extArray = function() {
    return null;
  };

  extArray.prototype = Object.create(Array.prototype);

  extArray.prototype.constructor = extArray;

  extArray.prototype.get_arrays = function(o) {
    var key, keys;

    keys = [];
    for (key in o) {
      if (o[key] instanceof Array) {
        keys.push(key);
      }
    }
    return keys;
  };

  extArray.prototype.for_arrays_of = function(obj, fnc, args) {
    var key, keys, ret, _i, _len;

    keys = this.get_arrays(obj);
    for (_i = 0, _len = keys.length; _i < _len; _i++) {
      key = keys[_i];
      ret = fnc(obj[key], args);
    }
    return ret;
  };

  extArray.prototype.add = function(v, i) {
    var ret;

    ret = -1;
    if ((i == null) || i === this.length) {
      this.push(v);
      this.for_arrays_of(this, function(o) {
        return o.push(null);
      });
      ret = this.length - 1;
    } else {
      if (i >= 0 && i < this.length) {
        this.push(this[i]);
        this[i] = v;
        this.for_arrays_of(this, function(o) {
          o.push(o[i]);
          return o[i] = null;
        });
        ret = i;
      }
    }
    return ret;
  };

  extArray.prototype.del = function(i) {
    if (i < 0 || i >= this.length) {
      return -1;
    }
    if (i < this.length - 1) {
      this.splice(i, 1, this.pop());
      this.for_arrays_of(this, function(o) {
        return o.splice(i, 1, o.pop());
      });
    } else {
      this.splice(i, 1);
      this.for_arrays_of(this, function(o) {
        return o.splice(i, 1);
      });
    }
    return i;
  };

  Nodes = function() {
    return null;
  };

  Nodes.prototype = Object.create(extArray.prototype);

  Nodes.prototype.constructor = Nodes;

  Edges = function() {
    return null;
  };

  Edges.prototype = Object.create(extArray.prototype);

  Edges.prototype.constructor = Edges;

  Events = function() {
    return null;
  };

  Events.prototype = Object.create(extArray.prototype);

  Events.prototype.constructor = Events;

  this.automata = (function() {
    var change_nodes, _this;

    change_nodes = function(G, i, a, b) {
      var ret;

      ret = [G.edges.a[i], G.edges.b[i]];
      G.edges.a[i] = a;
      G.edges.b[i] = b;
      return ret;
    };
    return _this = {
      create: function() {
        var o;

        o = {
          start: 0,
          nodes: new Nodes,
          edges: new Edges,
          events: new Events
        };
        o.edges.a = [];
        o.edges.b = [];
        o.edges.events = [];
        return o;
      },
      edges: {
        add: function(G, a, b, i) {
          if (a < 0 || b < 0 || a >= G.nodes.length || b >= G.nodes.length) {
            return -1;
          }
          i = G.edges.add(null, i);
          if (i >= 0) {
            G.edges.a[i] = a;
            G.edges.b[i] = b;
          }
          return i;
        },
        del: function(G, i) {
          return G.edges.del(i);
        },
        out: function(G, from_node) {
          var i, ret;

          ret = [];
          i = G.edges.length;
          while (i-- > 0) {
            if (G.edges.a[i] === from_node) {
              ret.push(i);
            }
          }
          return ret;
        },
        "in": function(G, to_node) {
          var i, ret;

          ret = [];
          i = G.edges.length;
          while (i-- > 0) {
            if (G.edges.b[i] === to_node) {
              ret.push(i);
            }
          }
          return ret;
        },
        has: function(G, a, b) {
          var i, ix, _i, _len, _ref;

          _ref = G.edges.b;
          for (ix = _i = 0, _len = _ref.length; _i < _len; ix = ++_i) {
            i = _ref[ix];
            if (G.edges.a[ix] === a && i === b) {
              return ix;
            }
          }
          return -1;
        },
        events: {
          add: function(G, edge, event) {
            if (edge < 0 || edge >= G.edges.length) {
              return -1;
            }
            if (event < 0 || event >= G.events.length) {
              return -1;
            }
            if (!(G.edges.events[edge] instanceof Array)) {
              G.edges.events[edge] = new Array;
            }
            if (G.edges.events[edge].indexOf(event) === -1) {
              G.edges.events[edge].push(event);
            }
            return event;
          },
          del: function(G, edge, event) {
            var ix;

            if (edge < 0 || edge >= G.edges.length) {
              return -1;
            }
            ix = G.edges.events[edge].indexOf(event);
            if (ix === -1) {
              return -1;
            }
            G.edges.events[edge].splice(event, 1);
            return ix;
          }
        }
      },
      nodes: {
        add: function(G, i) {
          return G.nodes.add(i);
        },
        del: function(G, i, on_del_edge) {
          var a, b, change, ix, last_node;

          last_node = G.nodes.length - 1;
          ix = G.edges.length;
          while (ix-- > 0) {
            a = G.edges.a[ix];
            b = G.edges.b[ix];
            if ((a === i) || (b === i)) {
              if (typeof on_del_edge === "function") {
                on_del_edge.apply(this, [G, ix]);
              } else {
                G.edges.del(i);
              }
            } else if (i < last_node) {
              change = false;
              if (a === last_node) {
                a = i;
                change = true;
              }
              if (b === last_node) {
                b = i;
                change = true;
              }
              if (change) {
                change_nodes(G, ix, a, b);
              }
            }
          }
          return G.nodes.del(i);
        },
        out: function(G, from_node) {
          var b, i, _i, _len, _ref, _results;

          _ref = G.edges.b;
          _results = [];
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            b = _ref[i];
            if (G.edges.a[i] === from_node) {
              _results.push(b);
            }
          }
          return _results;
        },
        "in": function(G, to_node) {
          var a, i, _i, _len, _ref, _results;

          _ref = G.edges.a;
          _results = [];
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            a = _ref[i];
            if (G.edges.b[i] === to_node) {
              _results.push(a);
            }
          }
          return _results;
        }
      },
      events: {
        add: function(G, v, i) {
          var ix;

          if ((ix = G.events.indexOf(v)) !== -1) {
            return ix;
          }
          return G.events.add(v, i);
        },
        del: function(G, i) {
          var events, _i, _len, _ref;

          _ref = G.edges.events;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            events = _ref[_i];
            if (events.indexOf(i) !== -1) {
              events.splice(i, 1);
            }
          }
          return G.events.del(i);
        }
      }
    };
  })();

}).call(this);
