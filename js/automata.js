// Generated by CoffeeScript 1.6.2
(function() {
  'use strict';
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  this.automata = (function() {
    var add, change_nodes, del, for_arrays_of, get_arrays, _this;

    add = function(arr, i) {
      var ret;

      ret = -1;
      if ((i == null) || i === arr.length) {
        arr.push(null);
        ret = arr.length - 1;
      } else {
        if (i >= 0 && i < arr.length) {
          arr.push(arr[i]);
          arr[i] = null;
          ret = i;
        }
      }
      return ret;
    };
    del = function(arr, i) {
      if (i < 0 || i >= arr.length || isNaN(i) || !(arr instanceof Array)) {
        return -1;
      }
      if (i < arr.length - 1) {
        arr.splice(i, 1, arr.pop());
      } else {
        arr.splice(i, 1);
      }
      return i;
    };
    get_arrays = function(o) {
      var key, keys;

      keys = [];
      for (key in o) {
        if (o.hasOwnProperty(key) && o[key] instanceof Array) {
          keys.push(key);
        }
      }
      return keys;
    };
    for_arrays_of = function(obj, fnc, args) {
      var key, keys, ret, _i, _len;

      keys = get_arrays(obj);
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        key = keys[_i];
        ret = fnc(obj[key], args);
      }
      return ret;
    };
    change_nodes = function(G, i, a, b) {
      var ret;

      ret = [G.edges.a[i], G.edges.b[i]];
      G.edges.a[i] = a;
      G.edges.b[i] = b;
      return ret;
    };
    return _this = {
      empty_string: '\u03b5',
      create: function() {
        return {
          start: 0,
          nodes: {
            v: []
          },
          edges: {
            v: [],
            a: [],
            b: [],
            events: []
          },
          events: []
        };
      },
      all: function(o, key, fnc) {
        var i, len;

        i = 0;
        len = o[key].length;
        if (typeof fnc === 'function') {
          while (i < len) {
            fnc(o, i++);
          }
        }
        return len;
      },
      edges: {
        add: function(G, a, b, i) {
          if (a < 0 || b < 0 || a >= G.nodes.length || b >= G.nodes.length) {
            return -1;
          }
          i = for_arrays_of(G.edges, add, i);
          if (i >= 0) {
            G.edges.a[i] = a;
            G.edges.b[i] = b;
          }
          return i;
        },
        del: function(G, i) {
          return for_arrays_of(G.edges, del, i);
        },
        out: function(G, from_node) {
          var ret;

          ret = [];
          _this.edges.all(G, function(edge, i) {
            if (edge.a[i] === from_node) {
              return ret.push(i);
            }
          });
          return ret;
        },
        "in": function(G, to_node) {
          var ret;

          ret = [];
          _this.edges.all(G, function(edge, i) {
            if (edge.b[i] === to_node) {
              return ret.push(i);
            }
          });
          return ret;
        },
        has: function(G, a, b) {
          var i, ix, _i, _len, _ref;

          _ref = G.edges.b;
          for (ix = _i = 0, _len = _ref.length; _i < _len; ix = ++_i) {
            i = _ref[ix];
            if (G.edges.a[ix] === a && i === b) {
              return ix;
            }
          }
          return -1;
        },
        all: function(G, fnc) {
          return _this.all(G.edges, 'v', fnc);
        },
        events: {
          add: function(G, edge, event) {
            if (edge < 0 || edge >= _this.edges.all(G)) {
              return -1;
            }
            if (event < 0 || event >= G.events.length) {
              return -1;
            }
            if (!(G.edges.events[edge] instanceof Array)) {
              G.edges.events[edge] = new Array;
            }
            if (G.edges.events[edge].indexOf(event) === -1) {
              G.edges.events[edge].push(event);
            }
            return event;
          },
          del: function(G, edge, event) {
            var ix;

            if (edge < 0 || edge >= _this.edges.all(G)) {
              return -1;
            }
            ix = G.edges.events[edge].indexOf(event);
            if (ix === -1) {
              return -1;
            }
            G.edges.events[edge].splice(event, 1);
            return ix;
          },
          labels: function(G, i) {
            var event, ret, _i, _len, _ref;

            ret = [];
            if ((G != null) && (i != null)) {
              if ((G.edges.events[i] != null) && G.edges.events[i].length !== 0) {
                _ref = G.edges.events[i];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  event = _ref[_i];
                  ret.push(G.events[event]);
                }
              } else {
                ret.push(automata.empty_string);
              }
            }
            return ret;
          }
        }
      },
      nodes: {
        add: function(G, i) {
          return for_arrays_of(G.nodes, add, i);
        },
        del: function(G, i, on_del_edge) {
          var a, b, change, ix, last_node;

          last_node = G.nodes.v.length - 1;
          ix = _this.edges.all(G);
          while (ix-- > 0) {
            a = G.edges.a[ix];
            b = G.edges.b[ix];
            if ((a === i) || (b === i)) {
              if (typeof on_del_edge === "function") {
                on_del_edge.apply(this, [G, ix]);
              } else {
                _this.edges.del(G, ix);
              }
            } else if (i < last_node) {
              change = false;
              if (a === last_node) {
                a = i;
                change = true;
              }
              if (b === last_node) {
                b = i;
                change = true;
              }
              if (change) {
                change_nodes(G, ix, a, b);
              }
            }
          }
          return for_arrays_of(G.nodes, del, i);
        },
        out: function(G, from_node) {
          var b, i, _i, _len, _ref, _results;

          _ref = G.edges.b;
          _results = [];
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            b = _ref[i];
            if (G.edges.a[i] === from_node) {
              _results.push(b);
            }
          }
          return _results;
        },
        "in": function(G, to_node) {
          var a, i, _i, _len, _ref, _results;

          _ref = G.edges.a;
          _results = [];
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            a = _ref[i];
            if (G.edges.b[i] === to_node) {
              _results.push(a);
            }
          }
          return _results;
        },
        all: function(G, fnc) {
          return _this.all(G.nodes, 'v', fnc);
        }
      },
      events: {
        add: function(G, v, i) {
          var ix;

          if ((ix = G.events.indexOf(v)) !== -1) {
            return ix;
          }
          i = add(G.events, i);
          G.events[i] = v;
          return i;
        },
        del: function(G, i) {
          var events, _i, _len, _ref;

          _ref = G.edges.events;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            events = _ref[_i];
            if (events.indexOf(i) !== -1) {
              events.splice(i, 1);
            }
          }
          return del(G.events, i);
        }
      }
    };
  })();

  /**
   * Breadth-first Search
   * @param {Automaton} G   
   * @param {function} fnc Callback function. Called with (node_from, label, node_to)
   * where:
   * node_from: index of the outgoing node
   * label: event label
   * node_to: index of the ingoing node
  */


  automata.BFS = function(G, fnc) {
    var E, a, b, e, l, labels, stack, visited, _i, _j, _len, _len1;

    if (G == null) {
      return null;
    }
    stack = [G.start];
    visited = [G.start];
    while (stack.length) {
      a = stack.pop();
      E = this.edges.out(G, a);
      for (_i = 0, _len = E.length; _i < _len; _i++) {
        e = E[_i];
        b = G.edges.b[e];
        if (__indexOf.call(visited, b) < 0) {
          visited.push(b);
          stack.push(b);
        }
        labels = this.edges.events.labels(G, e);
        if (typeof fnc === 'function') {
          for (_j = 0, _len1 = labels.length; _j < _len1; _j++) {
            l = labels[_j];
            fnc(a, l, b);
          }
        }
      }
    }
    return null;
  };

}).call(this);
