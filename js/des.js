// Generated by CoffeeScript 1.6.2
(function() {
  'use strict';
  var ARRAY_INCREMENT, BINARY_SUBSET, DES, E_CONFIG, NUMBER_SUBSET, OBJECT_SUBSET, T, TRIPLE_SUBSET, T_CONFIG, XX, X_CONFIG, clrUint16ArrayBit, create_general_set, delUint16ArrayBit, deserialize, e, enumArray, enumTripleArray, enumUint16ArrayBit, equal_arrays, getUint16ArrayBit, i, m, o, reach, resizeTripleArray, resizeUint16Array, resizeUint32Array, serialize, setUint16ArrayBit, sortIndexArray, str, _i, _len, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  E_CONFIG = {
    label: 'object',
    observable: 'boolean',
    controllable: 'boolean'
  };

  X_CONFIG = {
    x: 'integer',
    y: 'integer',
    label: 'object',
    marked: 'boolean',
    faulty: 'boolean'
  };

  T_CONFIG = {
    transitions: 'integer_triple',
    bends: 'boolean'
  };

  ARRAY_INCREMENT = 10 | 0;

  getUint16ArrayBit = function(arr, i) {
    return !!(arr[i >> 4] & 1 << (i & 0xF));
  };

  setUint16ArrayBit = function(arr, i) {
    return arr[i >> 4] |= 1 << (i & 0xF);
  };

  clrUint16ArrayBit = function(arr, i) {
    return arr[i >> 4] &= ~(1 << (i & 0xF));
  };

  resizeUint16Array = function(arr, len) {
    var ret;

    if (len > arr.length) {
      ret = new Uint16Array(len);
      ret.set(arr);
    } else {
      ret = new Uint16Array(arr.subarray(0, len));
    }
    return ret;
  };

  resizeUint32Array = function(arr, len) {
    var ret;

    if (len > arr.length) {
      ret = new Uint32Array(len);
      ret.set(arr);
    } else {
      ret = new Uint32Array(arr.subarray(0, len));
    }
    return ret;
  };

  delUint16ArrayBit = function(arr, i, bits_len) {
    bits_len -= 1;
    if (i !== bits_len) {
      if (getUint16ArrayBit(arr, bits_len)) {
        setUint16ArrayBit(arr, i);
      } else {
        clrUint16ArrayBit(arr, i);
      }
    }
    return bits_len;
  };

  enumUint16ArrayBit = function(arr, len) {
    var i, l, m, n, ret, v;

    ret = [];
    i = 0;
    l = arr.length;
    while (i < l) {
      v = arr[i];
      m = 0;
      n = i * 16;
      while (v && n + m < len) {
        if (v & 1) {
          ret.push(n + m);
        }
        v >>= 1;
        m++;
      }
      i++;
    }
    return ret;
  };

  enumArray = function(arr, len) {
    var i, l, ret;

    ret = [];
    i = 0;
    l = arr.length;
    if (len < l) {
      l = len;
    }
    while (i < l) {
      ret.push(arr[i]);
      i++;
    }
    return ret;
  };

  equal_arrays = function(a, b) {
    var i;

    i = a.length;
    if (i !== b.length) {
      return false;
    }
    while (i-- > 0) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  };

  resizeTripleArray = function(arr, len) {
    var ret;

    if (len * 3 > arr.length) {
      ret = new Uint32Array(len * 3);
      ret.set(arr);
    } else {
      ret = new Uint32Array(arr.subarray(0, len * 3));
    }
    return ret;
  };

  enumTripleArray = function(arr, len) {
    var i, l, ret;

    ret = [];
    i = 0;
    l = arr.length;
    if (len * 3 < l) {
      l = len * 3;
    }
    while (i < l) {
      ret.push(arr.subarray(i, i += 3));
    }
    return ret;
  };

  /**
   * [Optimized bubble sort (http://en.wikipedia.org/wiki/Bubble_sort). 
   * Sorts the index array instead of the array itself.]
   * @param  {[Array]} a   [Array with data]
   * @param  {[Array]} ix  [Index array to be sorted]
   * @param  {[int]} len [Length of the index array]
  */


  sortIndexArray = function(a, ix, len) {
    var i, j, m, n, temp;

    n = len;
    while (n) {
      m = 0;
      j = 0;
      i = 1;
      while (i < n) {
        if (a[ix[j]] > a[ix[i]]) {
          temp = ix[j];
          ix[j] = ix[i];
          ix[i] = temp;
          m = i;
        }
        j = i;
        i++;
      }
      n = m;
    }
  };

  BINARY_SUBSET = function() {
    var arr, o, self;

    arr = new Uint16Array(1);
    self = this;
    o = function() {
      return enumUint16ArrayBit(arr, self.size());
    };
    o.get = function(i) {
      if (i < self.size()) {
        return getUint16ArrayBit(arr, i);
      }
    };
    o.set = function(i) {
      if (i < self.size()) {
        setUint16ArrayBit(arr, i);
      }
      return self;
    };
    o.clr = function(i) {
      if (i < self.size()) {
        clrUint16ArrayBit(arr, i);
      }
      return self;
    };
    o.add = function() {
      if (this === self) {
        if ((arr.length << 4) <= self.size()) {
          arr = resizeUint16Array(arr, arr.length + 1);
        }
      }
      return null;
    };
    return o;
  };

  OBJECT_SUBSET = function() {
    var arr, o, self;

    arr = [];
    self = this;
    o = function() {
      return enumArray(arr, self.size());
    };
    o.get = function(i) {
      if (i < self.size()) {
        return arr[i];
      }
    };
    o.set = function(i, v) {
      if (i < self.size()) {
        arr[i] = v;
      }
      return self;
    };
    o.add = function() {
      if (this === self) {
        return arr.push(null);
      }
    };
    return o;
  };

  NUMBER_SUBSET = function() {
    var arr, o, self;

    arr = new Uint16Array(ARRAY_INCREMENT);
    self = this;
    o = function() {
      return enumArray(arr, self.size());
    };
    o.get = function(i) {
      if (i < self.size()) {
        return arr[i];
      }
    };
    o.set = function(i, v) {
      if (i < self.size()) {
        arr[i] = v;
      }
      return self;
    };
    o.add = function() {
      if (this === self) {
        if (arr.length < self.size() + 1) {
          arr = resizeUint16Array(arr, self.size() + ARRAY_INCREMENT);
        }
      }
      return null;
    };
    return o;
  };

  TRIPLE_SUBSET = function() {
    var arr, nix, o, self, sorted, tix;

    arr = new Uint32Array(ARRAY_INCREMENT * 3);
    tix = new Uint32Array(ARRAY_INCREMENT);
    nix = new Uint32Array();
    self = this;
    sorted = false;
    o = function() {
      return enumTripleArray(arr, self.size());
    };
    o.get = function(i) {
      if (i < self.size()) {
        return arr.subarray(i *= 3, i + 3);
      }
    };
    o.set = function(i, q, e, p) {
      i *= 3;
      if (i < arr.length - 2) {
        arr[i++] = q | 0;
        arr[i++] = e | 0;
        arr[i] = p | 0;
        sorted = false;
      }
      return self;
    };
    o.add = function() {
      if (this === self) {
        if (arr.length < (self.size() + 1) * 3) {
          arr = resizeTripleArray(arr, self.size() + ARRAY_INCREMENT);
          tix = resizeUint32Array(tix, self.size() + ARRAY_INCREMENT);
        }
      }
      return null;
    };
    o.sort = function() {
      var i;

      if (sorted) {
        return sorted;
      }
      i = self.size();
      while (i-- > 0) {
        tix[i] = i * 3 | 0;
      }
      sortIndexArray(arr, tix, self.size());
      return sorted = true;
    };
    o.max_state = function() {
      var i, max;

      i = 3 * self.size() | 0;
      max = 0;
      while (i-- > 0) {
        if (arr[i] > max) {
          max = arr[i];
        }
        i -= 2;
        if (arr[i] > max) {
          max = arr[i];
        }
      }
      return max;
    };
    o.out = function(q) {
      var i, ret;

      ret = [];
      i = 3 * self.size() | 0;
      i -= 3;
      while (i >= 0) {
        if (arr[i] === q) {
          ret.push((i / 3) | 0);
        }
        i -= 3;
      }
      return ret;
    };
    o.bfs = function(start, fnc) {
      var e, has_callback, i, ii, max, p, q, stack, t, visited, _i, _len;

      o.sort();
      has_callback = typeof fnc === 'function';
      max = o.max_state();
      visited = new Uint16Array(1 + (max >> 4));
      setUint16ArrayBit(visited, start);
      stack = [start];
      while (stack.length) {
        q = stack.pop();
        ii = o.out(q);
        for (_i = 0, _len = ii.length; _i < _len; _i++) {
          i = ii[_i];
          t = o.get(i);
          e = t[1];
          p = t[2];
          if (!getUint16ArrayBit(visited, p)) {
            setUint16ArrayBit(visited, p);
            stack.push(p);
          }
          if (has_callback) {
            fnc(q, e, p);
          }
        }
      }
      return visited = null;
    };
    o.reach = function(start, events) {
      var e, i, ii, p, q, reach, stack, t, _i, _len;

      stack = [start];
      reach = [start];
      while (stack.length) {
        q = stack.pop();
        ii = o.out(q);
        for (_i = 0, _len = ii.length; _i < _len; _i++) {
          i = ii[_i];
          t = o.get(i);
          e = t[1];
          p = t[2];
          if (__indexOf.call(events, e) < 0) {
            if (__indexOf.call(reach, p) < 0) {
              stack.push(p);
              reach.push(p);
            }
          }
        }
      }
      return reach.sort();
    };
    o.projection = function(start, events, callback) {
      var e, has_callback, i, ii, in_states, ix, next, p, pix, q, qix, reach, stack, states, t, _i, _j, _len, _len1;

      has_callback = typeof callback === 'function';
      reach = o.reach(start, events);
      stack = [reach];
      states = [reach];
      qix = 0;
      pix = 0;
      in_states = function(state) {
        var i;

        i = states.length;
        while (--i >= 0) {
          if (equal_arrays(states[i], state)) {
            break;
          }
        }
        return i;
      };
      while (stack.length) {
        reach = stack.pop();
        qix = in_states(reach);
        for (_i = 0, _len = reach.length; _i < _len; _i++) {
          q = reach[_i];
          ii = o.out(q);
          for (_j = 0, _len1 = ii.length; _j < _len1; _j++) {
            i = ii[_j];
            t = o.get(i);
            e = t[1];
            p = t[2];
            if (__indexOf.call(events, e) < 0) {
              continue;
            }
            next = o.reach(p, events);
            ix = in_states(next);
            if (ix < 0) {
              pix = states.length;
              stack.push(next);
              states.push(next);
            } else {
              pix = ix;
            }
            if (has_callback) {
              callback(qix, e, pix, reach, next);
            }
          }
        }
        qix++;
      }
      return states;
    };
    return o;
  };

  create_general_set = function(config) {
    var key, o, size;

    size = 0;
    config = config;
    o = function() {
      var i, key, obj, ret;

      if (arguments.length && 'number' === typeof (i = arguments[0] | 0)) {
        obj = {};
        for (key in config) {
          obj[key] = o[key].get(i);
        }
        return obj;
      }
      ret = [];
      i = size;
      while (i--) {
        obj = {};
        for (key in config) {
          obj[key] = o[key].get(i);
        }
        ret[i] = obj;
      }
      return ret;
    };
    o.size = function() {
      return size;
    };
    o.add = function() {
      var key;

      for (key in config) {
        this[key].add.apply(this);
      }
      return size++;
    };
    for (key in config) {
      switch (config[key]) {
        case 'boolean':
          o[key] = BINARY_SUBSET.apply(o);
          break;
        case 'integer':
          o[key] = NUMBER_SUBSET.apply(o);
          break;
        case 'object':
          o[key] = OBJECT_SUBSET.apply(o);
          break;
        case 'integer_triple':
          o[key] = TRIPLE_SUBSET.apply(o);
          break;
        default:
          console.log('Uknown configuration value');
      }
    }
    return o;
  };

  DES = {
    E: create_general_set(E_CONFIG),
    modules: [],
    make_module_from_T: function(T, name) {
      var module;

      module = {
        T: T,
        X: create_general_set(X_CONFIG)
      };
      module.name = name;
      module.X.start = 0;
      return module;
    },
    create_module: function(name) {
      var module;

      module = this.make_module_from_T(create_general_set(T_CONFIG), name);
      this.modules.push(module);
      return module;
    },
    BFS: function(module, fnc) {
      return module.T.transitions.bfs(module.X.start, fnc);
    },
    Projection: function(module, events) {
      var T;

      T = create_general_set(T_CONFIG);
      this.BFS(module, function(q, e, p) {
        if (events.indexOf(e) < 0) {
          e = 0;
        }
        return T.transitions.set(T.add(), q, e, p);
      });
      return T;
    }
  };

  this.DES = DES;

  console.clear();

  e = DES.E;

  e.label.set(e.add(), 'open');

  e.label.set(i = e.add(), 'close');

  e.observable.set(i);

  console.log('Events');

  console.table(e());

  m = DES.create_module('Motor');

  console.log('Modules');

  console.table(DES.modules);

  i = m.X.add();

  m.X.x.set(i, 12).y.set(i, 57).label.set(i, 'Initial').marked.set(i);

  i = m.X.add();

  m.X.label.set(i, 'NF');

  m.X.faulty.set(i, 'F');

  console.log('States');

  console.table(m.X());

  console.log('Marked states');

  console.table([m.X.marked()]);

  i = m.T.add();

  m.T.transitions.set(i, 0, 0, 1);

  i = m.T.add();

  m.T.transitions.set(i, 1, 2, 1);

  m.T.bends.set(i);

  m.T.transitions.set(m.T.add(), 1, 3, 2);

  m.T.transitions.set(m.T.add(), 0, 0, 0);

  console.log('Transitions');

  console.table(m.T.transitions());

  console.table(m.T.transitions().map(function(v) {
    return {
      from: m.X.label.get(v[0]),
      event: DES.E.label.get(v[1]),
      to: m.X.label.get(v[2])
    };
  }));

  console.log('Breadth-First Search');

  console.log('( X E X )', m.name);

  DES.BFS(m, function(q, e, p) {
    return console.log('(', q, e, p, ')');
  });

  console.log('Projection');

  m.projection = DES.Projection(m, [2, 3]);

  m.projection.transitions.bfs(m.X.start, function(q, e, p) {
    return console.log('(', q, e, p, ')');
  });

  console.log('Reachable set of states. From state 0, by events not [2, 3]');

  reach = m.T.transitions.reach(0, [2, 3]);

  console.log(reach);

  console.log('Projection');

  T = create_general_set(T_CONFIG);

  XX = [];

  m.T.transitions.projection(m.X.start, [2, 3], function(q, e, p, qq, pp) {
    T.transitions.set(T.add(), q, e, p);
    if (!XX[q]) {
      XX[q] = qq;
    }
    if (!XX[p]) {
      return XX[p] = pp;
    }
  });

  m = DES.make_module_from_T(T);

  console.log('( X E X )');

  DES.BFS(m, function(q, e, p) {
    return console.log('(', q, e, p, ')');
  });

  console.log('Projection with mapped states');

  DES.BFS(m, function(q, e, p) {
    return console.log('(', XX[q], e, XX[p], ')');
  });

  serialize = function() {
    var module, modules, _i, _len, _ref;

    modules = [];
    _ref = DES.modules;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      module = _ref[_i];
      m = {};
      m.name = module.name;
      m.T = module.T();
      m.X = module.X();
      modules.push(m);
    }
    return JSON.stringify(modules);
  };

  deserialize = function(str) {
    var X, ix, module, o, _i, _j, _len, _len1, _ref, _ref1;

    i = DES.modules.length;
    while (i-- > 0) {
      delete DES.modules[i];
      DES.modules[i] = null;
    }
    DES.modules.length = 0;
    o = JSON.parse(str);
    i = o.length;
    while (i-- > 0) {
      m = o[i];
      module = DES.create_module(m.name);
      T = m.T.length;
      _ref = m.T;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        T = _ref[_i];
        ix = module.T.add();
        module.T.bends.set(ix, T.bends);
        module.T.transitions.set(ix, T.transitions[0], T.transitions[1], T.transitions[2]);
      }
      console.log(m.X);
      X = m.X.length;
      _ref1 = m.X;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        X = _ref1[_j];
        ix = module.X.add();
        module.X.x.set(ix, X.x);
        module.X.y.set(ix, X.y);
        module.X.label.set(ix, X.label);
        if (X.marked) {
          module.X.marked.set(ix);
        }
        if (X.faulty) {
          module.X.faulty.set(ix);
        }
      }
    }
    return null;
  };

  o = {
    name: m.name,
    T: {
      transitions: m.T.transitions()
    }
  };

  str = serialize();

  deserialize(str);

  _ref = DES.modules;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    m = _ref[_i];
    console.log('( X E X )', m.name);
    DES.BFS(m, function(q, e, p) {
      return console.log('(', q, e, p, ')');
    });
    console.log('States');
    console.table(m.X());
    console.log('Marked states');
    console.table([m.X.marked()]);
  }

  console.table(m.T.transitions().map(function(v) {
    return {
      from: m.X.label.get(v[0]),
      event: DES.E.label.get(v[1]),
      to: m.X.label.get(v[2])
    };
  }));

}).call(this);
