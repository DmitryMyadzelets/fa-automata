// Generated by CoffeeScript 1.6.2
(function() {
  'use strict';
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  this.automata2 = (function() {
    var DELTA_TRANS, getBit, setBit, _this;

    DELTA_TRANS = 10;
    setBit = function(arr, i) {
      arr[i >> 5] |= 1 << (i & 0x1F);
      return null;
    };
    getBit = function(arr, i) {
      return arr[i >> 5] & 1 << (i & 0x1F) && 1;
    };
    return _this = {
      create: function() {
        return {
          start: 0 | 0,
          trans: new Uint32Array(3 * DELTA_TRANS),
          nN: 0 | 0,
          nE: 0 | 0,
          nT: 0 | 0
        };
      },
      trans: {
        add: function(G, q, e, p, i) {
          var j, k, len, t;

          len = G.trans.length | 0;
          j = G.nT * 3 | 0;
          if (j + 3 > len) {
            t = new Uint32Array(len + 3 * DELTA_TRANS);
            t.set(G.trans);
            delete G.trans;
            G.trans = t;
          }
          if ((i == null) || i === G.nT) {
            G.trans[j++] = q | 0;
            G.trans[j++] = e | 0;
            G.trans[j++] = p | 0;
            return G.nT++;
          } else {
            if (i < 0 || i > G.nT) {
              return -1 | 0;
            }
            k = i * 3 | 0;
            G.trans[j++] = G.trans[k++];
            G.trans[j++] = G.trans[k++];
            G.trans[j++] = G.trans[k++];
            k -= 3;
            G.trans[k++] = q | 0;
            G.trans[k++] = e | 0;
            G.trans[k++] = p | 0;
            G.nT++;
            return i | 0;
          }
        },
        del: function(G, i) {
          var j, len, t;

          if ((i == null) || i < 0 || i >= G.nT) {
            return -1;
          }
          G.nT -= 1;
          if (i < G.nT) {
            i *= 3;
            j = G.nT * 3;
            G.trans[i++] = G.trans[j++];
            G.trans[i++] = G.trans[j++];
            G.trans[i] = G.trans[j];
          }
          len = G.trans.length;
          if ((len - G.nT * 3) > 3 * DELTA_TRANS) {
            len -= 3 * DELTA_TRANS;
            t = new Uint32Array(G.trans.subarray(0, len));
            delete G.trans;
            G.trans = t;
          }
          return G.nT;
        },
        get: function(G, i) {
          if (i < 0 || i >= G.nT) {
            return -1 | 0;
          }
          return G.trans.subarray(i *= 3, i + 3);
        },
        out: function(G, q) {
          var i, n, ret;

          ret = [];
          n = G.nT * 3 | 0;
          i = 0 | 0;
          while (i < n) {
            if (G.trans[i] === q) {
              ret.push(i);
            }
            i += 3;
          }
          return new Uint32Array(ret);
        },
        "in": function(G, p) {
          var i, n, ret;

          ret = [];
          n = G.nT * 3 | 0;
          i = 2 | 0;
          while (i < n) {
            if (G.trans[i] === p) {
              ret.push(i - 2);
            }
            i += 3;
          }
          return new Uint32Array(ret);
        },
        exists: function(G, p, e, q) {
          var i, n, t;

          n = G.nT * 3 | 0;
          i = 0 | 0;
          t = G.trans;
          while (i < n) {
            if (t[i] === p && t[i + 1] === e && t[i + 2] === q) {
              return i;
            }
            i += 3;
          }
          return -1 | 0;
        }
      },
      edges: {}
      /**
      		 * Breadth-first Search
      		 * @param {Automaton} G   
      		 * @param {function} fnc Callback function. Called with (node_from, label, node_to)
      		 * where:
      		 * node_from: index of the outgoing node
      		 * label: event label
      		 * node_to: index of the ingoing node
      */

    };
  })();

  /**
   * Breadth-first Search
   * @param {Automaton} G   
   * @param {function} fnc Callback function. Called with (node_from, event, node_to)
   * where:
   * node_from: index of the outgoing node
   * event: index of event
   * node_to: index of the ingoing node
   * @return {null}
  */


  automata2.BFS = function(G, fnc) {
    var I, e, i, p, q, stack, visited, _i, _len;

    if (G == null) {
      return null;
    }
    stack = [G.start];
    visited = [G.start];
    while (stack.length) {
      q = stack.pop();
      I = this.trans.out(G, q);
      for (_i = 0, _len = I.length; _i < _len; _i++) {
        i = I[_i];
        e = G.trans[i + 1];
        p = G.trans[i + 2];
        if (__indexOf.call(visited, p) < 0) {
          visited.push(p);
          stack.push(p);
        }
        if (typeof fnc === 'function') {
          fnc(q, e, p);
        }
      }
    }
    return null;
  };

  /**
   * Parallel composition ('sync' name is taken from RW control theory)
   * @param  {automaton} G
   * @param  {automaton} H
   * @return {null}
  */


  automata2.sync = function(G, H) {
    if ((G == null) || !H) {
      return null;
    }
    return null;
  };

}).call(this);
