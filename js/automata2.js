// Generated by CoffeeScript 1.6.2
(function() {
  'use strict';
  var f, g;

  this.automata2 = (function() {
    var add, change_nodes, del, for_arrays_of, get_arrays, _this;

    add = function(arr, i) {
      var ret;

      ret = -1;
      if ((i == null) || i === arr.length) {
        arr.push(null);
        ret = arr.length - 1;
      } else {
        if (i >= 0 && i < arr.length) {
          arr.push(arr[i]);
          arr[i] = null;
          ret = i;
        }
      }
      return ret;
    };
    del = function(arr, i) {
      if (i < 0 || i >= arr.length || isNaN(i) || !(arr instanceof Array)) {
        return -1;
      }
      if (i < arr.length - 1) {
        arr.splice(i, 1, arr.pop());
      } else {
        arr.splice(i, 1);
      }
      return i;
    };
    get_arrays = function(o) {
      var key, keys;

      keys = [];
      for (key in o) {
        if (o.hasOwnProperty(key) && o[key] instanceof Array) {
          keys.push(key);
        }
      }
      return keys;
    };
    for_arrays_of = function(obj, fnc, args) {
      var key, keys, ret, _i, _len;

      keys = get_arrays(obj);
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        key = keys[_i];
        ret = fnc(obj[key], args);
      }
      return ret;
    };
    change_nodes = function(G, i, a, b) {
      var ret;

      ret = [G.edges.a[i], G.edges.b[i]];
      G.edges.a[i] = a;
      G.edges.b[i] = b;
      return ret;
    };
    return _this = {
      create: function() {
        return {
          start: 0,
          trans: new Uint32Array(),
          nN: 0,
          nE: 0,
          nT: 0
        };
      },
      trans: {
        add: function(G, q, e, p, i) {
          var ix, t;

          if (q < 0 || p < 0 || q >= G.nN || p >= G.nN) {
            return -1;
          }
          ix = G.trans.length;
          t = new Uint32Array(ix + 3);
          t.set(G.trans);
          delete G.trans;
          G.trans = t;
          t[ix++] = q;
          t[ix++] = e;
          t[ix++] = p;
          return G.nT = (ix / 3) | 0;
        },
        add2: function(G, q, e, p, i) {
          var ix, t;

          if (q < 0 || p < 0 || q >= G.nN || p >= G.nN) {
            return -1;
          }
          ix = G.trans.length;
          t = new Uint32Array(ix + 3);
          t.set(G.trans);
          t.set([q, e, p], ix);
          delete G.trans;
          G.trans = t;
          ix += 3;
          return G.nT = (ix / 3) | 0;
        },
        del: function(G, i) {
          var j, t;

          if (i < 0 || i >= G.nT) {
            return -1;
          }
          G.nT -= 1;
          if (i < G.nT) {
            i *= 3;
            j = G.nT * 3;
            G.trans[i++] = G.trans[j++];
            G.trans[i++] = G.trans[j++];
            G.trans[i] = G.trans[j];
          }
          t = new Uint32Array(G.trans.subarray(0, G.nT * 3));
          delete G.trans;
          G.trans = t;
          return G.nT;
        },
        get: function(G, i) {
          if (i < 0 || i >= G.nT) {
            return [];
          }
          return G.trans.subarray(i *= 3, i + 3);
        }
      },
      edges: {
        add: function(G, a, b, i) {
          if (a < 0 || b < 0 || a >= G.nodes.length || b >= G.nodes.length) {
            return -1;
          }
          i = for_arrays_of(G.edges, add, i);
          if (i >= 0) {
            G.edges.a[i] = a;
            G.edges.b[i] = b;
          }
          return i;
        },
        del: function(G, i) {
          return for_arrays_of(G.edges, del, i);
        },
        out: function(G, from_node) {
          var ret;

          ret = [];
          _this.edges.all(G, function(edge, i) {
            if (edge.a[i] === from_node) {
              return ret.push(i);
            }
          });
          return ret;
        },
        "in": function(G, to_node) {
          var ret;

          ret = [];
          _this.edges.all(G, function(edge, i) {
            if (edge.b[i] === to_node) {
              return ret.push(i);
            }
          });
          return ret;
        },
        has: function(G, a, b) {
          var i, ix, _i, _len, _ref;

          _ref = G.edges.b;
          for (ix = _i = 0, _len = _ref.length; _i < _len; ix = ++_i) {
            i = _ref[ix];
            if (G.edges.a[ix] === a && i === b) {
              return ix;
            }
          }
          return -1;
        },
        all: function(G, fnc) {
          return _this.all(G.edges, 'v', fnc);
        },
        events: {
          add: function(G, edge, event) {
            if (edge < 0 || edge >= _this.edges.all(G)) {
              return -1;
            }
            if (event < 0 || event >= G.events.length) {
              return -1;
            }
            if (!(G.edges.events[edge] instanceof Array)) {
              G.edges.events[edge] = new Array;
            }
            if (G.edges.events[edge].indexOf(event) === -1) {
              G.edges.events[edge].push(event);
            }
            return event;
          },
          del: function(G, edge, event) {
            var ix;

            if (edge < 0 || edge >= _this.edges.all(G)) {
              return -1;
            }
            ix = G.edges.events[edge].indexOf(event);
            if (ix === -1) {
              return -1;
            }
            G.edges.events[edge].splice(event, 1);
            return ix;
          },
          labels: function(G, i) {
            var event, ret, _i, _len, _ref;

            ret = [];
            if ((G != null) && (i != null)) {
              if ((G.edges.events[i] != null) && G.edges.events[i].length !== 0) {
                _ref = G.edges.events[i];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  event = _ref[_i];
                  ret.push(G.events[event]);
                }
              } else {
                ret.push(automata.empty_string);
              }
            }
            return ret;
          }
        }
      },
      nodes: {
        add: function(G, i) {
          return for_arrays_of(G.nodes, add, i);
        },
        del: function(G, i, on_del_edge) {
          var a, b, change, ix, last_node;

          last_node = G.nodes.v.length - 1;
          ix = _this.edges.all(G);
          while (ix-- > 0) {
            a = G.edges.a[ix];
            b = G.edges.b[ix];
            if ((a === i) || (b === i)) {
              if (typeof on_del_edge === "function") {
                on_del_edge.apply(this, [G, ix]);
              } else {
                _this.edges.del(G, ix);
              }
            } else if (i < last_node) {
              change = false;
              if (a === last_node) {
                a = i;
                change = true;
              }
              if (b === last_node) {
                b = i;
                change = true;
              }
              if (change) {
                change_nodes(G, ix, a, b);
              }
            }
          }
          return for_arrays_of(G.nodes, del, i);
        },
        out: function(G, from_node) {
          var b, i, _i, _len, _ref, _results;

          _ref = G.edges.b;
          _results = [];
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            b = _ref[i];
            if (G.edges.a[i] === from_node) {
              _results.push(b);
            }
          }
          return _results;
        },
        "in": function(G, to_node) {
          var a, i, _i, _len, _ref, _results;

          _ref = G.edges.a;
          _results = [];
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            a = _ref[i];
            if (G.edges.b[i] === to_node) {
              _results.push(a);
            }
          }
          return _results;
        },
        all: function(G, fnc) {
          return _this.all(G.nodes, 'v', fnc);
        }
      },
      events: {
        add: function(G, v, i) {
          var ix;

          if ((ix = G.events.indexOf(v)) !== -1) {
            return ix;
          }
          i = add(G.events, i);
          G.events[i] = v;
          return i;
        },
        del: function(G, i) {
          var events, _i, _len, _ref;

          _ref = G.edges.events;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            events = _ref[_i];
            if (events.indexOf(i) !== -1) {
              events.splice(i, 1);
            }
          }
          return del(G.events, i);
        }
      }
    };
  })();

  g = automata2.create();

  g.nN = 10;

  automata2.trans.add2(g, 0, 1, 2);

  automata2.trans.add2(g, 3, 4, 5);

  automata2.trans.add2(g, 6, 7, 8);

  console.log(g.trans);

  automata2.trans.del(g, 1);

  console.log(g.trans);

  console.log(f = automata2.trans.get(g, 0));

  f.set([22, 15, 16]);

  console.log(g.trans);

}).call(this);
