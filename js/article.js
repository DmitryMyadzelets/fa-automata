// Generated by CoffeeScript 1.6.2
(function() {
  'use strict';
  var get_event_by_labels, m, make_F_module, make_NF_module, make_N_module, make_projection, set_transitions, show_dfs, show_events, show_modules, show_modules_transitions, show_states, show_transitions, transitions,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  (function() {
    var E, e, events, i, key, _i, _len, _results;

    events = [
      {
        labels: 'a'
      }, {
        labels: 'b'
      }, {
        labels: 'c'
      }, {
        labels: 'd'
      }, {
        labels: 'e'
      }, {
        labels: 'f',
        fault: true
      }, {
        labels: 'o1',
        observable: true
      }, {
        labels: 'o2',
        observable: true
      }
    ];
    E = DES.E;
    _results = [];
    for (_i = 0, _len = events.length; _i < _len; _i++) {
      e = events[_i];
      i = E.add();
      _results.push((function() {
        var _results1;

        _results1 = [];
        for (key in e) {
          _results1.push(E[key].set(i, e[key]));
        }
        return _results1;
      })());
    }
    return _results;
  })();

  get_event_by_labels = function(labels) {
    var i;

    i = DES.E.size();
    while (i-- > 0) {
      if (DES.E.labels.get(i) === labels) {
        break;
      }
    }
    return i;
  };

  set_transitions = function(m, transitions) {
    var eid, i, t, _i, _len;

    for (_i = 0, _len = transitions.length; _i < _len; _i++) {
      t = transitions[_i];
      if ((eid = get_event_by_labels(t[1])) >= 0) {
        m.T.transitions.set(m.T.add(), t[0], eid, t[2]);
      } else {
        console.log('Error:', t[1], 'labels not found');
      }
    }
    i = 1 + m.T.transitions.max_state();
    while (i-- > 0) {
      m.X.add();
    }
    return null;
  };

  show_events = function() {
    console.log('Events:');
    return console.table(DES.E());
  };

  show_states = function(m) {
    console.log('States of module', m.name);
    return console.table(m.X());
  };

  show_transitions = function(m) {
    console.log('Transitions of module', m.name);
    return console.table(m.T.transitions().map(function(v) {
      return {
        from: v[0],
        event: DES.E.labels.get(v[1]),
        to: v[2]
      };
    }));
  };

  show_modules = function() {
    console.log('Modules:');
    console.table(DES.modules);
  };

  show_modules_transitions = function() {
    var m, _i, _len, _ref;

    _ref = DES.modules;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      m = _ref[_i];
      show_transitions(m);
    }
  };

  show_dfs = function(m) {
    console.log('Depth-First Search of module', m.name);
    DES.DFS(m, function(q, e, p) {
      console.log(q, DES.E.labels.get(e), p);
      return true;
    });
  };

  transitions = [[0, 'f', 1], [1, 'a', 2], [2, 'o1', 3], [3, 'b', 4], [4, 'c', 4], [0, 'o1', 5], [5, 'c', 5]];

  m = DES.add_module('G1');

  set_transitions(m, transitions);

  transitions = [[0, 'a', 1], [1, 'd', 2], [2, 'c', 2], [0, 'c', 0]];

  m = DES.add_module('G2');

  set_transitions(m, transitions);

  transitions = [[0, 'b', 1], [1, 'e', 2], [2, 'c', 2], [0, 'c', 0]];

  m = DES.add_module('G3 Valve');

  set_transitions(m, transitions);

  transitions = [[0, 'e', 1], [1, 'o2', 2], [2, 'd', 3], [3, 'c', 3], [0, 'c', 0]];

  m = DES.add_module('G4 Motor');

  set_transitions(m, transitions);

  (function() {
    var eid, i, index, modules, t, _i, _len, _ref, _results;

    _ref = DES.modules;
    _results = [];
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      m = _ref[index];
      i = m.T.size();
      _results.push((function() {
        var _results1;

        _results1 = [];
        while (i-- > 0) {
          t = m.T.transitions.get(i);
          eid = t[1];
          modules = DES.E.modules.get(eid);
          if (!modules) {
            modules = [];
          }
          if (__indexOf.call(modules, index) < 0) {
            modules.push(index);
            _results1.push(DES.E.modules.set(eid, modules));
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      })());
    }
    return _results;
  })();

  make_NF_module = function(m) {
    var M, T, flt, in_map, map, process_state, to_map, tt;

    tt = m.T.transitions;
    map = [];
    flt = [];
    M = DES.create_module('NF(' + m.name + ')');
    T = M.T;
    in_map = function(q, fault) {
      var i;

      i = map.length;
      while (i-- > 0) {
        if ((map[i] === q) && (flt[i] === fault)) {
          break;
        }
      }
      return i;
    };
    to_map = function(q, fault) {
      var x;

      map.push(q);
      flt.push(fault);
      x = M.X.add();
      if (fault) {
        M.X.faulty.set(x);
      }
      return map.length - 1;
    };
    process_state = function(q, fault) {
      var e, f, i, ii, p, pp, qq, t, _i, _len;

      qq = to_map(q, fault);
      if (m.X.faulty.get(q)) {
        fault = true;
      }
      ii = tt.out(q);
      for (_i = 0, _len = ii.length; _i < _len; _i++) {
        i = ii[_i];
        t = tt.get(i);
        e = t[1];
        p = t[2];
        f = fault || DES.E.fault.get(e);
        pp = in_map(p, f);
        if (pp < 0) {
          pp = process_state(p, f);
        }
        T.transitions.set(T.add(), qq, e, pp);
      }
      return qq;
    };
    process_state(m.X.start, false);
    return M;
  };

  make_N_module = function(m) {
    var M, T, in_map, map, process_state, to_map, tt;

    tt = m.T.transitions;
    M = DES.create_module('N(' + m.name + ')');
    T = M.T;
    map = [];
    in_map = function(q) {
      var i;

      i = map.length;
      while (i-- > 0) {
        if (map[i] === q) {
          break;
        }
      }
      return i;
    };
    to_map = function(q) {
      var x;

      map.push(q);
      x = M.X.add();
      return map.length - 1;
    };
    process_state = function(q) {
      var e, i, ii, p, pp, qq, t, _i, _len;

      qq = to_map(q);
      ii = tt.out(q);
      for (_i = 0, _len = ii.length; _i < _len; _i++) {
        i = ii[_i];
        t = tt.get(i);
        e = t[1];
        p = t[2];
        if (DES.E.fault.get(e) || m.X.faulty.get(p)) {
          continue;
        }
        pp = in_map(p);
        if (pp < 0) {
          pp = process_state(p);
        }
        M.X.marked.set(pp);
        T.transitions.set(T.add(), qq, e, pp);
      }
      return qq;
    };
    process_state(m.X.start);
    return M;
  };

  make_F_module = function(m) {
    var M, T, faulty, in_map, map;

    M = DES.create_module('F(' + m.name + ')');
    T = M.T;
    map = [];
    faulty = new bitArray(m.X.size());
    in_map = function(q) {
      var i;

      i = map.length;
      while (i-- > 0) {
        if (map[i] === q) {
          break;
        }
      }
      return i;
    };
    DES.DFS(m, function(q, e, p) {
      var x;

      if (!faulty.get(p) && (m.X.faulty.get(q) || DES.E.fault.get(e))) {
        faulty.set(p);
        map.push(p);
        x = M.X.add();
        M.X.faulty.set(x);
        M.X.marked.set(x);
      }
      return true;
    }, function(q, e, p) {
      if (!faulty.get(q) && faulty.get(p)) {
        faulty.set(q);
        map.push(q);
        M.X.add();
      }
      return true;
    });
    DES.DFS(m, function(q, e, p) {
      if (faulty.get(p)) {
        T.transitions.set(T.add(), in_map(q), e, in_map(p));
      }
      return true;
    });
    M.X.start = in_map(m.X.start);
    return M;
  };

  make_projection = function(m, events) {
    var M, T;

    M = DES.create_module('P(' + m.name + ')');
    T = M.T;
    M.X.start = 0;
    m.T.transitions.projection(m.X.start, events, function(q, e, p, qq, pp) {
      var i, _i, _len;

      T.transitions.set(T.add(), q, e, p);
      if (q >= M.X.size()) {
        q = M.X.add();
      }
      if (p >= M.X.size()) {
        p = M.X.add();
      }
      if (!M.X.marked.get(p)) {
        for (_i = 0, _len = pp.length; _i < _len; _i++) {
          i = pp[_i];
          if (m.X.marked.get(i)) {
            M.X.marked.set(p);
            break;
          }
        }
      }
    });
    return M;
  };

  console.log('====================================================');

  show_modules();

  show_events();

  (function() {
    var i, j, modules, _results;

    i = DES.modules.length;
    _results = [];
    while (i-- > 0) {
      m = DES.modules[i];
      m.common = [];
      j = DES.E.size();
      while (j-- > 0) {
        modules = DES.E.modules.get(j);
        if ((modules.length > 1) && (__indexOf.call(modules, i) >= 0)) {
          m.common.push(j);
        }
      }
      _results.push(m.C = make_projection(m, m.common));
    }
    return _results;
  })();

  (function() {
    var _i, _len, _ref, _results;

    _ref = DES.modules;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      m = _ref[_i];
      m.F = DES.create_module('F');
      m.N = DES.create_module('N');
      _results.push(m.subcommon = m.common.slice());
    }
    return _results;
  })();

  (function() {
    var f, i, n, nf, propagate_FN;

    i = 0;
    m = DES.modules[i];
    nf = make_NF_module(m);
    n = make_N_module(nf);
    f = make_F_module(nf);
    m.N = make_projection(n, m.common);
    m.F = make_projection(f, m.common);
    propagate_FN = function(k, F, N) {
      var F_, Fc, Fj_, K, NF_, N_, Nc, Nj_, cap, common, index, j, _i, _len, _ref;

      _ref = DES.modules;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        j = _ref[index];
        if (index === i) {
          continue;
        }
        common = intersection(k.common, j.common);
        if (common.length === 0) {
          continue;
        }
        if (j.subcommon.length === 0) {
          continue;
        }
        Fc = DES.sync(F, j.C, common);
        Nc = DES.sync(N, j.C, common);
        Fj_ = make_projection(Fc, j.common);
        Nj_ = make_projection(Nc, j.common);
        K = DES.intersection(Fj_, Nj_);
        DES.closure(K);
        DES.subtract(Fj_, K);
        DES.subtract(Nj_, K);
        DES.subtract(Fj_, j.F);
        DES.subtract(Nj_, j.N);
        if (!DES.is_empty(Fj_) || !DES.is_empty(Nj_)) {
          j.F = DES.sync(j.F, Fj_);
          j.N = DES.sync(j.N, Nj_);
          j.F.name = 'F';
          j.N.name = 'N';
          console.log('updated', j.name);
          F_ = DES.copy(j.F);
          N_ = DES.copy(j.N);
          DES.closure(F_);
          DES.closure(N_);
          cap = DES.intersection(F_, N_);
          DES.subtract(F_, j.F);
          DES.subtract(N_, j.N);
          NF_ = DES.sync(F_, N_, j.common);
          DES.subtract(NF_, cap);
        }
        break;
      }
    };
    return propagate_FN(m, m.F, m.N);
  })();

}).call(this);
