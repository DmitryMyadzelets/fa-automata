// Generated by CoffeeScript 1.6.2
/*
The functions here assume that there are global variables:
	array of automations "automata",
	array of graphics "graphics",
	radius of states "r",
	half radian "PI2".
*/


(function() {
  'use strict';
  var PI2, angle_from, angle_to, cl_black, cl_edge, cl_node, cl_node_edge, cl_node_sel, cl_text, draw_markedState, empty_string, loop_k;

  this.r = 16;

  PI2 = Math.PI * 2;

  cl_black = "rgba(0,0,0, 0.8)";

  cl_node = "#fec867";

  cl_text = cl_black;

  cl_edge = cl_black;

  cl_node_edge = cl_black;

  cl_node_sel = "#da5d00";

  empty_string = "\u03b5";

  /*
  ===============================================================================
  */


  this.draw_state = function(ctx, x, y) {
    ctx.beginPath();
    ctx.arc(x, y, r, 0, PI2, true);
    ctx.fill();
    ctx.stroke();
    return null;
  };

  /*
  ===============================================================================
  */


  draw_markedState = function(ctx, x, y) {
    ctx.save();
    ctx.fillStyle = "rgba(0,0,255,0.2)";
    ctx.beginPath();
    ctx.arc(x, y, r, 0, PI2, true);
    ctx.fill();
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(x, y, r + 4, 0, PI2, true);
    ctx.stroke();
    ctx.restore();
    return null;
  };

  /*
  ===============================================================================
  The functions draws stright directed edge from coordinates (x1, y1) to (x2, y2).
  */


  this.calc_arrow = function(to, norm, orth, v) {
    v[0] = to[0];
    v[1] = to[1];
    v[2] = v[0] - (10 * norm[0]) + (4 * norm[1]);
    v[3] = v[1] - (10 * norm[1]) - (4 * norm[0]);
    v[4] = v[2] - (8 * norm[1]);
    v[5] = v[3] + (8 * norm[0]);
    return null;
  };

  this.calc_norm_ort = function(v1, v2, norm, orth) {
    var dl, dx, dy;

    dx = v2[0] - v1[0];
    dy = v2[1] - v1[1];
    dl = Math.sqrt(dx * dx + dy * dy);
    if (dl === 0) {
      return [];
    }
    norm[0] = dx / dl;
    norm[1] = dy / dl;
    orth[0] = norm[1];
    orth[1] = -norm[0];
    return null;
  };

  this.calc_edge = function(v1, v2, norm) {
    v1[0] += r * norm[0];
    v1[1] += r * norm[1];
    v2[0] -= r * norm[0];
    v2[1] -= r * norm[1];
    return null;
  };

  this.calc_curved = function(v1, v2, norm, orth, cv, arrow) {
    var n, o;

    calc_norm_ort(v1, v2, norm, orth);
    cv[0] = (v1[0] + v2[0]) / 2 + norm[1] * 40;
    cv[1] = (v1[1] + v2[1]) / 2 - norm[0] * 40;
    n = [];
    o = [];
    calc_norm_ort(v1, cv, n, o);
    calc_edge(v1, [], n);
    calc_norm_ort(cv, v2, n, o);
    calc_edge([], v2, n);
    calc_arrow(v2, n, o, arrow);
    return null;
  };

  this.draw_edge = function(ctx, v1, v2) {
    ctx.beginPath();
    ctx.moveTo(v1[0], v1[1]);
    ctx.lineTo(v2[0], v2[1]);
    ctx.stroke();
    return null;
  };

  this.draw_curved = function(ctx, v1, v2, cv) {
    ctx.beginPath();
    ctx.moveTo(v1[0], v1[1]);
    ctx.quadraticCurveTo(cv[0], cv[1], v2[0], v2[1]);
    ctx.stroke();
    return null;
  };

  this.draw_arrow = function(ctx, v) {
    ctx.beginPath();
    ctx.lineTo(v[0], v[1]);
    ctx.lineTo(v[2], v[3]);
    ctx.lineTo(v[4], v[5]);
    ctx.stroke();
    ctx.fill();
    return null;
  };

  this.draw_fake_edge = function(ctx, x1, y1, x2, y2, new_edge) {
    var norm, orth, v;

    norm = [];
    orth = [];
    calc_norm_ort([x1, y1], [x2, y2], norm, orth);
    x1 = x1 + r * norm[0];
    y1 = y1 + r * norm[1];
    if (!new_edge) {
      x2 = x2 - r * norm[0];
      y2 = y2 - r * norm[1];
    }
    ctx.save();
    ctx.fillStyle = cl_edge;
    ctx.strokeStyle = cl_edge;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    v = [];
    calc_arrow([x2, y2], norm, orth, v);
    draw_arrow(ctx, v);
    ctx.restore();
    return null;
  };

  /*
  ===============================================================================
  */


  angle_from = Math.PI / 3;

  angle_to = Math.PI / 12;

  loop_k = {
    dx1: r * Math.cos(angle_from),
    dy1: r * Math.sin(angle_from),
    dx2: r * 4 * Math.cos(angle_from),
    dy2: r * 4 * Math.sin(angle_from),
    dx3: r * 4 * Math.cos(angle_to),
    dy3: r * 4 * Math.sin(angle_to),
    dx4: r * Math.cos(angle_to),
    dy4: r * Math.sin(angle_to),
    nx: Math.cos(angle_from - Math.PI / 24),
    ny: Math.sin(angle_from - Math.PI / 24)
  };

  /*
  ===============================================================================
  */


  this.draw_loop = function(ctx, x, y) {
    var k, nx, ny, ox, oy, x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6;

    nx = -loop_k.nx;
    ny = loop_k.ny;
    ox = ny;
    oy = -nx;
    x1 = x + loop_k.dx1;
    y1 = y - loop_k.dy1;
    k = 4 * r;
    x2 = x + loop_k.dx2;
    y2 = y - loop_k.dy2;
    x3 = x + loop_k.dx3;
    y3 = y - loop_k.dy3;
    x4 = x + loop_k.dx4;
    y4 = y - loop_k.dy4;
    x5 = x1 - (10 * nx) + (4 * ox);
    y5 = y1 - (10 * ny) + (4 * oy);
    x6 = x5 - (8 * ox);
    y6 = y5 - (8 * oy);
    ctx.save();
    ctx.fillStyle = cl_edge;
    ctx.strokeStyle = cl_edge;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.bezierCurveTo(x2, y2, x3, y3, x4, y4);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x5, y5);
    ctx.lineTo(x6, y6);
    ctx.lineTo(x1, y1);
    ctx.stroke();
    ctx.fill();
    ctx.restore();
    return null;
  };

  /*
  ===============================================================================
  */


  /*
  ===============================================================================
  */


  this.draw_graph = function(ctx, G) {
    var index, ix, text, v1, v2, x, x1, x2, y, y1, y2, _i, _len, _ref;

    ctx.save();
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.strokeStyle = cl_node_edge;
    _ref = G.nodes.x;
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      x = _ref[index];
      y = G.nodes.y[index];
      ctx.fillStyle = cl_node;
      draw_state(ctx, x, y);
      text = index.toString();
      ctx.fillStyle = cl_text;
      ctx.fillText(text, x, y);
    }
    ix = G.edges.length;
    while (ix-- > 0) {
      v1 = G.edges.a[ix];
      v2 = G.edges.b[ix];
      x1 = G.nodes.x[v1];
      y1 = G.nodes.y[v1];
      x2 = G.nodes.x[v2];
      y2 = G.nodes.y[v2];
      if (v1 !== v2) {
        if (G.edges.curved[ix]) {
          draw_curved(ctx, G.edges.v1[ix], G.edges.v2[ix], G.edges.cv[ix]);
          draw_arrow(ctx, G.edges.arrow[ix]);
        } else {
          ctx.fillStyle = cl_edge;
          ctx.strokeStyle = cl_edge;
          draw_edge(ctx, G.edges.v1[ix], G.edges.v2[ix]);
          draw_arrow(ctx, G.edges.arrow[ix]);
        }
      } else {
        draw_loop(ctx, x1, y1);
      }
    }
    ctx.restore();
    return null;
  };

  /*
  ===============================================================================
  */


  this.draw_automaton = function(ctx, G) {
    var ix, text, v1, v2, x, x1, x2, y, y1, y2;

    draw_graph(ctx, G);
    x = G.nodes.x[G.start] - 4 * r;
    y = G.nodes.y[G.start];
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = cl_black;
    ix = G.edges.length;
    text = "";
    while (ix-- > 0) {
      v1 = G.edges.a[ix];
      v2 = G.edges.b[ix];
      x1 = G.nodes.x[v1];
      y1 = G.nodes.y[v1];
      x2 = G.nodes.x[v2];
      y2 = G.nodes.y[v2];
      if (v1 !== v2) {
        if (G.edges.curved[ix]) {
          x = G.edges.cv[ix][0];
          y = G.edges.cv[ix][1];
        } else {
          x = x1 + (x2 - x1) / 2 + r * G.edges.orth[ix][0];
          y = y1 + (y2 - y1) / 2 + r * G.edges.orth[ix][1];
        }
      } else {
        x = x1 + 2 * r;
        y = y1 - 3 * r;
      }
      if (G.edges.event[ix] != null) {
        text = empty_string;
      } else {
        text = empty_string;
      }
      ctx.fillText(text, x, y);
    }
    return null;
  };

}).call(this);
