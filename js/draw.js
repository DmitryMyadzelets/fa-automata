// Generated by CoffeeScript 1.6.2
/*
The functions here assume that there are global variables:
	array of automations "automata",
	array of graphics "graphics",
	radius of states "r",
	half radian "PI2".
*/


(function() {
  'use strict';
  var PI2, angle_from, angle_to, cl_black, cl_edge, cl_node, cl_node_edge, cl_node_sel, cl_text, draw_markedState, empty_string, loop_k;

  this.r = 16;

  PI2 = Math.PI * 2;

  cl_black = "rgba(0,0,0, 0.8)";

  cl_node = "#fec867";

  cl_text = cl_black;

  cl_edge = cl_black;

  cl_node_edge = cl_black;

  cl_node_sel = "#da5d00";

  empty_string = "\u03b5";

  /*
  ===============================================================================
  */


  this.draw_state = function(ctx, x, y) {
    ctx.beginPath();
    ctx.arc(x, y, r, 0, PI2, true);
    ctx.fill();
    ctx.stroke();
    return null;
  };

  /*
  ===============================================================================
  */


  draw_markedState = function(ctx, x, y) {
    ctx.beginPath();
    ctx.arc(x, y, r, 0, PI2, true);
    ctx.fill();
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(x, y, r + 4, 0, PI2, true);
    ctx.stroke();
    return null;
  };

  /*
  ===============================================================================
  */


  this.draw_edge = function(ctx, v1, v2) {
    ctx.beginPath();
    ctx.moveTo(v1[0], v1[1]);
    ctx.lineTo(v2[0], v2[1]);
    ctx.stroke();
    return null;
  };

  this.draw_curved = function(ctx, v1, v2, cv) {
    ctx.beginPath();
    ctx.moveTo(v1[0], v1[1]);
    ctx.quadraticCurveTo(cv[0], cv[1], v2[0], v2[1]);
    ctx.stroke();
    return null;
  };

  this.draw_arrow = function(ctx, v) {
    ctx.beginPath();
    ctx.lineTo(v[0], v[1]);
    ctx.lineTo(v[2], v[3]);
    ctx.lineTo(v[4], v[5]);
    ctx.stroke();
    ctx.fill();
    return null;
  };

  this.draw_fake_edge = function(ctx, o) {
    ctx.save();
    ctx.fillStyle = cl_edge;
    ctx.strokeStyle = cl_edge;
    draw_edge(ctx, o.v1, o.v2);
    draw_arrow(ctx, o.arrow);
    ctx.restore();
    return null;
  };

  /*
  ===============================================================================
  */


  angle_from = Math.PI / 3;

  angle_to = Math.PI / 12;

  loop_k = {
    dx1: r * Math.cos(angle_from),
    dy1: r * Math.sin(angle_from),
    dx2: r * 4 * Math.cos(angle_from),
    dy2: r * 4 * Math.sin(angle_from),
    dx3: r * 4 * Math.cos(angle_to),
    dy3: r * 4 * Math.sin(angle_to),
    dx4: r * Math.cos(angle_to),
    dy4: r * Math.sin(angle_to),
    nx: Math.cos(angle_from - Math.PI / 24),
    ny: Math.sin(angle_from - Math.PI / 24)
  };

  /*
  ===============================================================================
  */


  this.draw_loop = function(ctx, x, y) {
    var k, nx, ny, ox, oy, x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6;

    nx = -loop_k.nx;
    ny = loop_k.ny;
    ox = ny;
    oy = -nx;
    x1 = x + loop_k.dx1;
    y1 = y - loop_k.dy1;
    k = 4 * r;
    x2 = x + loop_k.dx2;
    y2 = y - loop_k.dy2;
    x3 = x + loop_k.dx3;
    y3 = y - loop_k.dy3;
    x4 = x + loop_k.dx4;
    y4 = y - loop_k.dy4;
    x5 = x1 - (10 * nx) + (4 * ox);
    y5 = y1 - (10 * ny) + (4 * oy);
    x6 = x5 - (8 * ox);
    y6 = y5 - (8 * oy);
    ctx.save();
    ctx.fillStyle = cl_edge;
    ctx.strokeStyle = cl_edge;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.bezierCurveTo(x2, y2, x3, y3, x4, y4);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x5, y5);
    ctx.lineTo(x6, y6);
    ctx.lineTo(x1, y1);
    ctx.stroke();
    ctx.fill();
    ctx.restore();
    return null;
  };

  /*
  ===============================================================================
  */


  this.draw_automaton = function(ctx, G) {
    var $, ix, text, v1, v2, x, x1, x2, y, y1, y2;

    ctx.save();
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = cl_black;
    ctx.fillStyle = cl_edge;
    ctx.strokeStyle = cl_edge;
    text = "";
    draw_fake_edge(ctx, G.edges.start);
    ix = G.edges.length;
    while (ix-- > 0) {
      v1 = G.edges.a[ix];
      v2 = G.edges.b[ix];
      x1 = G.nodes.x[v1];
      y1 = G.nodes.y[v1];
      x2 = G.nodes.x[v2];
      y2 = G.nodes.y[v2];
      $ = G.edges.$[ix];
      if (v1 === v2) {
        draw_loop(ctx, x1, y1);
        x = x1 + 2 * r;
        y = y1 - 3 * r;
      } else {
        if ($.curved) {
          draw_curved(ctx, $.v1, $.v2, $.cv);
          draw_arrow(ctx, $.arrow);
          x = $.cv[0] + (-5) * $.norm[1];
          y = $.cv[1] - (-5) * $.norm[0];
        } else {
          draw_edge(ctx, $.v1, $.v2);
          draw_arrow(ctx, $.arrow);
          x = x1 + (x2 - x1) / 2 + 0.5 * r * $.norm[1];
          y = y1 + (y2 - y1) / 2 - 0.5 * r * $.norm[0];
        }
      }
      if (G.edges.event[ix] != null) {
        text = empty_string;
      } else {
        text = empty_string;
      }
      ctx.fillText(text, x, y);
    }
    ix = G.nodes.length;
    while (ix-- > 0) {
      x = G.nodes.x[ix];
      y = G.nodes.y[ix];
      ctx.fillStyle = cl_node;
      draw_state(ctx, x, y);
      text = ix.toString();
      ctx.fillStyle = cl_text;
      ctx.fillText(text, x, y);
    }
    ctx.restore();
    return null;
  };

}).call(this);
