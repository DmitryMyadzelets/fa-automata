// Generated by CoffeeScript 1.6.2
(function() {
  'use strict';
  var PI2, angle_from, angle_to, cl_black, cl_edge, cl_node, cl_node_edge, cl_node_sel, cl_text, empty_string, loop_k;

  this.r = 16;

  PI2 = Math.PI * 2;

  cl_black = "rgba(0,0,0, 0.8)";

  cl_node = "#fec867";

  cl_text = cl_black;

  cl_edge = cl_black;

  cl_node_edge = cl_black;

  cl_node_sel = "#da5d00";

  empty_string = "\u03b5";

  /*
  ===============================================================================
  */


  /**
   * A wrapper (Module pattern) for drawing methods
   * @return {Object}
  */


  this.draw = (function() {
    var _this;

    _this = {
      /**
      		 * Draws a state of the automaton
      		 * @param  {canvas} ctx
      		 * @param  {Number} x
      		 * @param  {Number} y
      		 * @return {null}
      */

      state: function(ctx, x, y) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, PI2, true);
        ctx.fill();
        ctx.stroke();
        return null;
      },
      /**
      		 * Draws marked state
      		 * @param  {canvas} ctx
      		 * @param  {Number} x
      		 * @param  {Number} y
      		 * @return {null}
      */

      marked: function(ctx, x, y) {
        draw_state(ctx, x, y);
        ctx.beginPath();
        ctx.arc(x, y, r + 4, 0, PI2, true);
        ctx.stroke();
        return null;
      },
      /**
      		 * Draws a line (edge) from vector v1 to vector v2
      		 * @param  {canvas} ctx
      		 * @param  {[Number, Number]} v1 Coordinates [x, y]
      		 * @param  {[Number, Number]} v2 Coordinates [x, y]
      		 * @return {null}
      */

      edge: function(ctx, v1, v2) {
        ctx.beginPath();
        ctx.moveTo(v1[0], v1[1]);
        ctx.lineTo(v2[0], v2[1]);
        ctx.stroke();
        return null;
      },
      /**
      		 * Draws a quadratic curve line from vector v1 to vector v2
      		 * @param  {canvas} ctx
      		 * @param  {[Number, Number]} v1 Coordinates
      		 * @param  {[Number, Number]} v2 Coordinates
      		 * @param  {[Number, Number]} cv Control vector
      		 * @return {null}
      */

      curved: function(ctx, v1, v2, cv) {
        ctx.beginPath();
        ctx.moveTo(v1[0], v1[1]);
        ctx.quadraticCurveTo(cv[0], cv[1], v2[0], v2[1]);
        ctx.stroke();
        return null;
      },
      /**
      		 * Draws an arrow
      		 * @param  {canvas} ctx
      		 * @param  {Number[6]} v Array of 3 vectors
      		 * @return {null}
      */

      arrow: function(ctx, v) {
        ctx.beginPath();
        ctx.lineTo(v[0], v[1]);
        ctx.lineTo(v[2], v[3]);
        ctx.lineTo(v[4], v[5]);
        ctx.stroke();
        ctx.fill();
        return null;
      },
      /**
      		 * Draws a loop edge
      		 * @param  {canvas} ctx
      		 * @param  {Number} x Coordinate of the node
      		 * @param  {Number} y Coordinate of the node
      		 * @return {null}
      */

      loop: function(ctx, v1, v2, cv) {
        ctx.save();
        ctx.fillStyle = cl_edge;
        ctx.strokeStyle = cl_edge;
        ctx.beginPath();
        ctx.moveTo(v1[0], v1[1]);
        ctx.bezierCurveTo(cv[0], cv[1], cv[2], cv[3], v2[0], v2[1]);
        ctx.stroke();
        ctx.restore();
        return null;
      },
      /**
      		 * The above functions are structure-independent.
      		 * The below functions are dependent on the automaton structure
      		 * described in the 'faxy.coffee' file
      */

      /**
      		 * Draws an edge
      		 * @param  {canvas} ctx
      		 * @param  {Object} o Parameters of the edge
      		 * 						o.v1 vector 'from'
      		 * 						o.v2 vector 'to'
      		 * 						o.arrow
      		 * @return {null}
      */

      fake_edge: function(ctx, o) {
        ctx.save();
        ctx.fillStyle = cl_edge;
        ctx.strokeStyle = cl_edge;
        _this.edge(ctx, o.v1, o.v2);
        _this.arrow(ctx, o.arrow);
        ctx.restore();
        return null;
      },
      /**
      		 * Draws automaton graph on canvas
      		 * @param  {canvas} ctx
      		 * @param  {faxy} G Automaton structure
      		 * @return {null}
      */

      automaton: function(ctx, G) {
        var $, ix, text, v1, v2, x, x1, x2, y, y1, y2;

        ctx.save();
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = cl_black;
        ctx.fillStyle = cl_edge;
        ctx.strokeStyle = cl_edge;
        text = "";
        _this.fake_edge(ctx, G.edges.start);
        ix = G.edges.length;
        while (ix-- > 0) {
          v1 = G.edges.a[ix];
          v2 = G.edges.b[ix];
          x1 = G.nodes.x[v1];
          y1 = G.nodes.y[v1];
          x2 = G.nodes.x[v2];
          y2 = G.nodes.y[v2];
          $ = G.edges.$[ix];
          switch ($.type) {
            case 0:
              _this.edge(ctx, $.v1, $.v2);
              _this.arrow(ctx, $.arrow);
              x = x1 + (x2 - x1) / 2 + 0.5 * r * $.norm[1];
              y = y1 + (y2 - y1) / 2 - 0.5 * r * $.norm[0];
              break;
            case 1:
              _this.curved(ctx, $.v1, $.v2, $.cv);
              _this.arrow(ctx, $.arrow);
              x = $.cv[0] + (-5) * $.norm[1];
              y = $.cv[1] - (-5) * $.norm[0];
              break;
            case 2:
              _this.loop(ctx, $.v1, $.v2, $.cv);
              _this.arrow(ctx, $.arrow);
              x = x1 + 2 * r;
              y = y1 - 3 * r;
          }
          if (G.edges.event[ix] != null) {
            text = empty_string;
          } else {
            text = empty_string;
          }
          ctx.fillText(text, x, y);
        }
        ix = G.nodes.length;
        while (ix-- > 0) {
          x = G.nodes.x[ix];
          y = G.nodes.y[ix];
          ctx.fillStyle = cl_node;
          _this.state(ctx, x, y);
          text = ix.toString();
          ctx.fillStyle = cl_text;
          ctx.fillText(text, x, y);
        }
        ctx.restore();
        return null;
      }
    };
    return _this;
  })();

  /*
  ===============================================================================
  */


  angle_from = Math.PI / 3;

  angle_to = Math.PI / 12;

  loop_k = {
    dx1: r * Math.cos(angle_from),
    dy1: r * Math.sin(angle_from),
    dx2: r * 4 * Math.cos(angle_from),
    dy2: r * 4 * Math.sin(angle_from),
    dx3: r * 4 * Math.cos(angle_to),
    dy3: r * 4 * Math.sin(angle_to),
    dx4: r * Math.cos(angle_to),
    dy4: r * Math.sin(angle_to),
    nx: Math.cos(angle_from - Math.PI / 24),
    ny: Math.sin(angle_from - Math.PI / 24)
  };

}).call(this);
